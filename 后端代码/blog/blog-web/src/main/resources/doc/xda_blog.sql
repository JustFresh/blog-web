/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50711
Source Host           : localhost:3306
Source Database       : xda

Target Server Type    : MYSQL
Target Server Version : 50711
File Encoding         : 65001

Date: 2019-01-29 12:26:38
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for xda_blog_admin
-- ----------------------------
DROP TABLE IF EXISTS `xda_blog_admin`;
CREATE TABLE `xda_blog_admin` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `description` varchar(1000) DEFAULT NULL COMMENT '备注字段',
  `is_del` tinyint(2) NOT NULL DEFAULT '0' COMMENT '删除标识（1删除，0未删除）',
  `last_modified_date` datetime DEFAULT NULL COMMENT '最近修改时间',
  `status` tinyint(2) NOT NULL DEFAULT '1' COMMENT '账号状态（1启用，0禁用）',
  `last_login_ip` varchar(64) DEFAULT NULL COMMENT '最近登录IP地址',
  `login_num` int(11) DEFAULT '0' COMMENT '登录次数',
  `nick_name` varchar(64) NOT NULL COMMENT '管理员昵称',
  `password` varchar(64) NOT NULL COMMENT '管理员登录密码',
  `username` varchar(64) NOT NULL COMMENT '管理员登录名',
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_chi5gt26vkuq5a9n4k8arj8s2` (`nick_name`),
  UNIQUE KEY `UK_e5a3thprjpqidno5loae2n0m7` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of xda_blog_admin
-- ----------------------------
INSERT INTO `xda_blog_admin` VALUES ('2', '2018-11-24 15:59:09', '测试修改属性', '0', '2018-11-24 15:59:09', '1', null, '0', 'JustFresh', '5d38ddf094c29b07f3b7507bdba32275', 'admin');
INSERT INTO `xda_blog_admin` VALUES ('12', '2018-12-12 15:56:35', null, '0', '2018-12-13 10:19:18', '0', '', '0', '34534', '5d38ddf094c29b07f3b7507bdba32275', '33332432');
INSERT INTO `xda_blog_admin` VALUES ('13', '2018-12-12 16:02:37', null, '0', null, '1', '', '0', '张三疯', '5d38ddf094c29b07f3b7507bdba32275', 'user');
INSERT INTO `xda_blog_admin` VALUES ('14', '2018-12-12 16:03:30', null, '0', '2018-12-13 10:10:25', '1', '', '0', '吴彦祖', '5d38ddf094c29b07f3b7507bdba32275', 'apollo');
INSERT INTO `xda_blog_admin` VALUES ('15', '2018-12-12 16:27:13', null, '0', null, '1', '', '0', '32423', '5d38ddf094c29b07f3b7507bdba32275', '11111111111');
INSERT INTO `xda_blog_admin` VALUES ('16', '2018-12-12 16:42:58', null, '0', null, '1', '', '0', '3343', '5d38ddf094c29b07f3b7507bdba32275', '啊啊啊啊');
INSERT INTO `xda_blog_admin` VALUES ('17', '2018-12-13 09:28:35', null, '0', null, '1', '', '0', '赵子龙', '5d38ddf094c29b07f3b7507bdba32275', 'JustFresh');
INSERT INTO `xda_blog_admin` VALUES ('19', '2018-12-13 10:45:21', null, '0', null, '1', '', '0', 'AAAAAAAAAA', '5d38ddf094c29b07f3b7507bdba32275', 'aoc');
INSERT INTO `xda_blog_admin` VALUES ('20', '2018-12-13 10:45:40', null, '0', null, '1', '', '0', '哎呦哎呦喂', '5d38ddf094c29b07f3b7507bdba32275', 'AMB');
INSERT INTO `xda_blog_admin` VALUES ('21', '2018-12-13 10:45:54', null, '0', null, '1', '', '0', '赵信', '5d38ddf094c29b07f3b7507bdba32275', 'wuwuw');
INSERT INTO `xda_blog_admin` VALUES ('22', '2018-12-13 10:46:17', null, '0', null, '1', '', '0', '上单盖伦', '5d38ddf094c29b07f3b7507bdba32275', 'gailun');

-- ----------------------------
-- Table structure for xda_blog_adv
-- ----------------------------
DROP TABLE IF EXISTS `xda_blog_adv`;
CREATE TABLE `xda_blog_adv` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `description` varchar(1000) DEFAULT NULL COMMENT '备注字段',
  `is_del` tinyint(2) NOT NULL DEFAULT '0' COMMENT '删除标识（1删除，0未删除）',
  `last_modified_date` datetime DEFAULT NULL COMMENT '最近修改时间',
  `status` tinyint(2) NOT NULL DEFAULT '1' COMMENT '账号状态（1启用，0禁用）',
  `adv_name` varchar(255) NOT NULL COMMENT '广告名称',
  `adv_type` tinyint(2) NOT NULL DEFAULT '1' COMMENT '广告类型',
  `adv_url` varchar(255) NOT NULL DEFAULT '#' COMMENT '链接地址',
  `click_num` int(11) DEFAULT '0' COMMENT '点击量',
  `is_blank` tinyint(2) DEFAULT '0' COMMENT '是否新窗口打开',
  `position_id` int(11) DEFAULT NULL COMMENT '所属广告位ID',
  `reorder` int(11) DEFAULT '1' COMMENT '排序',
  `thumb` varchar(255) NOT NULL DEFAULT '#' COMMENT '广告图片',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of xda_blog_adv
-- ----------------------------
INSERT INTO `xda_blog_adv` VALUES ('1', '2018-12-17 16:57:10', '', '0', '2018-12-22 06:20:18', '1', '测试广告', '2', '#', '0', '0', '2', '1', '/Uploads/images/adv/2018/12/22/20181222062016.jpg');
INSERT INTO `xda_blog_adv` VALUES ('2', '2018-12-17 17:11:49', '', '0', '2018-12-22 06:20:26', '1', '啊啊啊啊啊', '1', '#', '0', '0', '3', '1', '/Uploads/images/adv/2018/12/22/20181222062024.jpg');
INSERT INTO `xda_blog_adv` VALUES ('3', '2018-12-18 06:24:29', '', '0', '2018-12-22 06:20:35', '1', '3333', '1', '#', '0', '0', '1', '2', '/Uploads/images/adv/2018/12/22/20181222062034.jpg');

-- ----------------------------
-- Table structure for xda_blog_article
-- ----------------------------
DROP TABLE IF EXISTS `xda_blog_article`;
CREATE TABLE `xda_blog_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `description` varchar(1000) DEFAULT NULL COMMENT '备注字段',
  `is_del` tinyint(2) NOT NULL DEFAULT '0' COMMENT '删除标识（1删除，0未删除）',
  `last_modified_date` datetime DEFAULT NULL COMMENT '最近修改时间',
  `status` tinyint(2) NOT NULL DEFAULT '1' COMMENT '账号状态（1启用，0禁用）',
  `abstracts` varchar(1000) DEFAULT NULL COMMENT '文章简介',
  `author` varchar(64) DEFAULT NULL COMMENT '文章作者',
  `click_num` int(11) DEFAULT '0' COMMENT '点击次数',
  `content` text COMMENT '文章内容',
  `is_recommend` tinyint(2) DEFAULT '0' COMMENT '是否为推荐文章',
  `is_top` tinyint(2) DEFAULT '0' COMMENT '是否为置顶文章',
  `keywords` varchar(1000) DEFAULT NULL COMMENT '文章关键字',
  `source` varchar(64) DEFAULT NULL COMMENT '文章来源',
  `thumb` varchar(128) DEFAULT NULL COMMENT '文章缩略图',
  `title` varchar(256) NOT NULL COMMENT '文章标题',
  `channel_id` int(11) NOT NULL COMMENT '文章所属栏目',
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_pjoo4ta1mcuv8ucrs1fdb7x74` (`title`),
  KEY `FKhc5a3v79w2xwltawmmx4fyrr2` (`channel_id`),
  CONSTRAINT `FKhc5a3v79w2xwltawmmx4fyrr2` FOREIGN KEY (`channel_id`) REFERENCES `xda_blog_channel` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of xda_blog_article
-- ----------------------------
INSERT INTO `xda_blog_article` VALUES ('3', '2018-12-22 06:39:45', '', '0', '2019-01-23 17:05:54', '1', '最近由于公司新项目的需求，需要用到spring cloud微服务架构体系，感谢公司领导给了我此次机会能从头开始学习微服务体系架构并使用，到现在学习了二十一天了，把自己这段时间的学习做一个记录吧，本次记录会按照如下步骤进行，并且会从编写博客此时起再一次重新搭建项目把自己的所学再过一遍，最终完成可运行代码会上传github并附上具体地址，若本文出现纰漏或错误，请各位看官各位大神给予指正并轻点喷。', 'JustFresh', '3', '<p>点我点我:<a href=\"https://github.com/JustFresh/micro\" target=\"_blank\">项目github地址</a>。</p>\n\n<p>1、简述。</p>\n\n<p>最近由于公司新项目的需求，需要用到spring cloud微服务架构体系，感谢公司领导给了我此次机会能从头开始学习微服务体系架构并使用，到现在学习了二十一天了，把自己这段时间的学习做一个记录吧，本次记录会按照如下步骤进行，并且会从编写博客此时起再一次重新搭建项目把自己的所学再过一遍，最终完成可运行代码会上传github并附上具体地址，若本文出现纰漏或错误，请各位看官各位大神给予指正并轻点喷。</p>\n\n<p>1）Eclipse安装STS以及HelloWorld的编写。</p>\n\n<p>2）Eureka注册中心及微服务的注册（服务名为serviceAdd&mdash;&mdash;提供a+b计算服务）。</p>\n\n<p>3）serviceMultipl（提供a*b服务）服务的编写以及微服务打包jar和war部署。</p>\n\n<p>4）Fegin客户端负载均衡服务调用以及Hystrix断路器效果实现。</p>\n\n<p>5）ZUUL路由网关项目编写以及服务调用。</p>\n\n<p>6）zipkin服务链路追踪。</p>\n\n<p>7）JPA调用数据库（SSH+MySql）的增删改查实现。</p>\n\n<p>8）Spring Boot Admin服务监控实现。</p>\n\n<p><img alt=\"20180403233504631.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180416/1523893816751084820.jpg\" /></p>\n\n<p>3、预计实现达到效果。</p>\n\n<p>1）Eureka服务注册中心能分别注册add服务、multipl服务（由8084、8085端口分别提供，实现负载均衡）、zuul服务（8089端口）、feign客户端调用负载均衡服务(8087端口)、feign客户端负载均衡及Hystrix断路器效果服务(8088端口实现)、SSH+MySql+Thymeleaf增删改查实例服务。</p>\n\n<p>2）分别通过直接调用微服务（访问具体微服务地址）以及通过网关ZUUL调用微服务实现。</p>\n\n<p>3）通过Feign客户端调用能够实现负载均衡。</p>\n\n<p>4）通过Hystrix配置能够在微服务节点服务down的同时达到服务&ldquo;断路&rdquo;效果。</p>\n\n<p>5）ssh+MySql/Oracle连接及基本的增删改查实例。</p>\n\n<p>6）zipkin微服务之间调用关系的显示及SpringBootAdmin服务监控效果。</p>\n\n<p>4、微服务打包war包部署到tomcat。</p>\n\n<p>5、微服务打包部署jboss Eap 6.4（除Eureka之外）。</p>\n', '0', '0', 'SpringCloud,Java,JF', '', '/Uploads/images/article/2018/12/22/20181222063943.jpg', 'SpringCloud学习记录——序', '1');
INSERT INTO `xda_blog_article` VALUES ('4', '2018-12-22 06:41:32', '', '0', null, '1', '参照：https://blog.csdn.net/u010101142/article/details/55001302（方案一）\nhttps://jingyan.baidu.com/article/1612d5005fd087e20f1eee10.html（方案二）\n本人使用方案一安装成功，安装成功后即可通过Eclipse new项目的时候能选择新建SpringBoot工程，如下图：', 'JustFresh', '0', '<p>点我点我:<a href=\"https://github.com/JustFresh/micro\" target=\"_blank\">项目github地址</a>。</p>\n\n<p>1、Eclipse安装STS插件(springsource-tool-suite)。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;参照：<a href=\"https://blog.csdn.net/u010101142/article/details/55001302\" target=\"_blank\">https://blog.csdn.net/u010101142/article/details/55001302</a>（方案一）</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://jingyan.baidu.com/article/1612d5005fd087e20f1eee10.html\" target=\"_blank\">https://jingyan.baidu.com/article/1612d5005fd087e20f1eee10.html</a>（方案二）</p>\n\n<p>&nbsp; &nbsp; 本人使用方案一安装成功，安装成功后即可通过Eclipse new项目的时候能选择新建SpringBoot工程，如下图：</p>\n\n<p><img alt=\"20180404093636805.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523962925745000329.jpg\" /></p>\n\n<p>2、HelloWorld。</p>\n\n<p>打开Eclipse，点击文件&mdash;&mdash;&gt;新建&mdash;&mdash;&gt;其他</p>\n\n<p><img alt=\"20180404093439514.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523962987308022338.jpg\" /></p>\n\n<p>图2</p>\n\n<p>选择Spring Start Project（参看图1），填写项目名、项目类型（此处选择maven）、选择打包方式（Jar或War均可）、填写Maven所需Group和Artifact所需变量，填写包名称，如图3：</p>\n\n<p><img alt=\"20180404094054846.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523963115233082473.jpg\" /></p>\n\n<p>图3</p>\n\n<p>点击下一步，选择SpringBoot版本，依赖搜索框输入web，选中Web复选框，如图4.</p>\n\n<p><img alt=\"4.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523963208078009541.jpg\" /></p>\n\n<p>点击下一步、点击完成即可完成项目新建，新建完成项目结构如图5，其中pom.xml为maven包引用文件，application.properties文件为整个项目的配置文件，DemoApplication为项目启动类，启动类就包含一个main方法即可。</p>\n\n<p><img alt=\"5.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523963236657081981.jpg\" /></p>\n\n<p>图5</p>\n\n<p>新建一个HelloController，类注解@RestController（注解@Controller也可，可参看此文章：<a href=\"https://blog.csdn.net/gg12365gg/article/details/51345601\" target=\"_blank\">查看两者区别</a>），新建一个sayHello方法，返回一个&ldquo;HelloWorld&rdquo;字符串，如图6所示。</p>\n\n<p><img alt=\"6.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523963283830060967.jpg\" /></p>\n\n<p>选中DemoApplication.java类，右键运行方式&mdash;&mdash;&gt;Spring Boot App即可启动项目（如图7），项目启动完毕浏览器输入<a href=\"http://localhost:8080/hello%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0HelloWorld%E7%9A%84%E8%BF%94%E5%9B%9E%EF%BC%88%E5%A6%82%E5%9B%BE8%E6%89%80%E7%A4%BA%EF%BC%89%EF%BC%8C%E5%88%B0%E6%AD%A4%E6%95%B4%E4%B8%AASpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84HelloWorld%E5%8D%B3%E5%B7%B2%E7%BC%96%E5%86%99%E5%AE%8C%E6%AF%95%E3%80%82\">http://localhost:8080/hello即可看到HelloWorld的返回（如图8所示），到此整个SpringBoot项目的HelloWorld即已编写完毕。</a></p>\n\n<p><img alt=\"7.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523963344128096285.jpg\" /></p>\n\n<p>图7</p>\n\n<p><img alt=\"8.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523963365331001179.jpg\" /></p>\n\n<p>图8</p>\n', '0', '0', 'SpringCloud,Java,JF,helloworld', '', '/Uploads/images/article/2018/12/22/20181222064131.jpg', 'SpringCloud学习记录——HelloWorld的开始', '1');
INSERT INTO `xda_blog_article` VALUES ('5', '2018-12-22 06:46:22', '', '0', null, '1', 'Eureka是Netflix开源的一款提供服务注册和发现的产品，它提供了完整的Service Registry和Service Discovery实现。也是springcloud体系中最重要最核心的组件之一。', 'JustFresh', '0', '<p>点我点我:<a href=\"https://github.com/JustFresh/micro\" target=\"_blank\">项目github地址</a>。</p>\n\n<p>1、Eureka注册中心搭建。</p>\n\n<p>新建Maven Project，命名为micro，整体架构父项目，用作整体SpringBoot版本控制。Group Id、Artifact Id、Package随意命名即可（此示例Group Id：com.xiudoua.study、Artifact Id：micro、Package：com.xiudoua.study.micro）,修改pom.xml文件中打包方式为pom，pom.xml文件添加如下SpringBoot依赖指向。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>新建maven module，命名为micro-eureka，父项目指向micro，打包方式选择jar，新建方式选择&ldquo;maven-archetype-webapp&rdquo;，如图1所示：</p>\n\n<p><img alt=\"1.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523963865122024290.jpg\" /></p>\n\n<p>图1</p>\n\n<p>pom.xml文件添加properties声明配置编码格式及java版本，引入spring-boot-starter-web、spring-boot-starter-test、spring-cloud-starter-eureka-server、javax.servlet-api。声明spring-cloud-dependencies版本，bulid标签添加spring-boot-maven-plugin插件，整体pom.xml代码如下：</p>\n\n<p><img alt=\"2.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523964605746075429.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>在src/main/java目录下新建com.xiudoua.study.micro包，在此包下新建一个EurekaApplication.java类，其中@SpringBootApplication代表此项目为SpringBoot工程，@EnableEurekaServer代表此服务以Eureka注册中心方式启动，代码如下：</p>\n\n<ol>\n	<li>\n	<p>package&nbsp;com.xiudoua.study.micro;&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>import&nbsp;org.springframework.boot.SpringApplication;&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>import&nbsp;org.springframework.boot.autoconfigure.SpringBootApplication;&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>import&nbsp;org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>@EnableEurekaServer&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>@SpringBootApplication&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>public&nbsp;class&nbsp;EurekaApplication&nbsp;{&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringApplication.run(EurekaApplication.class,&nbsp;args);&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>}&nbsp;&nbsp;</p>\n	</li>\n</ol>\n\n<p>在src/main/resources目录下新建application.properties文件（此处可新建application.properties或者application.yml文件做配置均可），文件结构如下：&nbsp;<a href=\"https://blog.csdn.net/u012459871/article/details/79813558#\" target=\"_self\">view pla</a></p>\n\n<p>&nbsp;</p>\n\n<ol>\n	<li>\n	<p>#标注服务名称&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>spring.application.name=eureka&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>#标注服务端口号，若不配置默认为8080；如若打包到tomcat或者jboss容器部署，则端口配置不生效，以容器端口为准&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>server.port=8080 &nbsp;</p>\n	</li>\n	<li>\n	<p>#标注Eureka注册中心不进行自我注册&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>eureka.client.register-with-eureka=false&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>eureka.client.fetch-registry=false &nbsp;</p>\n	</li>\n	<li>\n	<p>#配置注册中心地址&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>eureka.client.serviceUrl.defaultZone=http://localhost:${server.port}/eureka/ &nbsp;</p>\n	</li>\n	<li>\n	<p>#配置注册中心页面控制台地址，若不配置，默认为/&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>eureka.dashboard.path=/eurekaUI&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>选中EurekaApplication.java文件，右键以Spring Boot APP启动，浏览器输入http://localhost:8080/eurekaUI，访问如下界面（图2）则即为Eureka注册中心搭建成功。</p>\n	</li>\n	<li>\n	<p><img alt=\"1.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523965049457032628.jpg\" /></p>\n	</li>\n	<li>\n	<p>2、serviceAdd微服务编写并注册到Eureka。</p>\n	</li>\n	<li>\n	<p>新建maven module，命名为micro-serviceAdd，父项目指向micro，打包方式选择jar，新建方式选择&ldquo;maven-archetype-webapp&rdquo;。</p>\n	</li>\n	<li>\n	<p>pom.xml文件编码、java版本、SpringCloud声明引用版本、spring-boot-maven-plugin插件引用均与Eureka注册中心一致，但应去除注册中心的spring-cloud-starter-eureka-server引用并引入spring-cloud-starter-eureka，pom.xml整体文件如下：</p>\n	</li>\n	<li>\n	<p><img alt=\"pom.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523965326400017703.jpg\" /></p>\n	</li>\n	<li>\n	<p>在src/main/java目录下新建com.xiudoua.study.micro包，在此包下新建一个ServiceAddApplication.java类，其中@SpringBootApplication代表此项目为SpringBoot工程，@EnableDiscoveryClient标注此微服务可被注册中心发现，@ComponentScan注解标注SpringBoot项目的包注解扫描，代码如下：</p>\n	</li>\n	<li>\n	<p>package com.xiudoua.study.micro;</p>\n	</li>\n	<li>\n	<p>import org.springframework.boot.SpringApplication; &nbsp;</p>\n	</li>\n	<li>\n	<p>import org.springframework.boot.autoconfigure.SpringBootApplication; &nbsp;</p>\n	</li>\n	<li>\n	<p>import org.springframework.cloud.client.discovery.EnableDiscoveryClient; &nbsp;</p>\n	</li>\n	<li>\n	<p>import org.springframework.context.annotation.ComponentScan; &nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp;&nbsp;</p>\n	</li>\n	<li>\n	<p>@EnableDiscoveryClient &nbsp;</p>\n	</li>\n	<li>\n	<p>@SpringBootApplication &nbsp;</p>\n	</li>\n	<li>\n	<p>@ComponentScan({&quot;com.xiudoua.study.micro.controller&quot;}) &nbsp;</p>\n	</li>\n	<li>\n	<p>public class ServiceAddApplication { &nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp; &nbsp; public static void main(String[] args) { &nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp; &nbsp; &nbsp; &nbsp; SpringApplication.run(ServiceAddApplication.class, args); &nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp; &nbsp; } &nbsp;</p>\n	</li>\n	<li>\n	<p>}&nbsp;</p>\n	</li>\n	<li>\n	<p>在src/main/java目录下新建com.xiudoua.study.micro.controller包，在此包新建AddController类，此类提供一个计算a+b之和的服务，代码如下：</p>\n	</li>\n	<li>\n	<p>package com.xiudoua.study.micro.controller; &nbsp;</p>\n	</li>\n	<li>\n	<p>import org.springframework.web.bind.annotation.RequestMapping; &nbsp;</p>\n	</li>\n	<li>\n	<p>import org.springframework.web.bind.annotation.RequestMethod; &nbsp;</p>\n	</li>\n	<li>\n	<p>import org.springframework.web.bind.annotation.RequestParam; &nbsp;</p>\n	</li>\n	<li>\n	<p>import org.springframework.web.bind.annotation.RestController; &nbsp;</p>\n	</li>\n	<li>\n	<p>@RestController &nbsp;</p>\n	</li>\n	<li>\n	<p>public class AddController { &nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp; &nbsp; @RequestMapping(value = &quot;/addTwoNum&quot;,method = RequestMethod.GET) &nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp; &nbsp; public String addTowNum(@RequestParam Integer a,@RequestParam Integer b){ &nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp; &nbsp; &nbsp; &nbsp; return &quot;公用调用a+b方法返回结果为：&quot; + (a + b); &nbsp;</p>\n	</li>\n	<li>\n	<p>&nbsp; &nbsp; } &nbsp;</p>\n	</li>\n	<li>\n	<p>} &nbsp;</p>\n	</li>\n	<li>\n	<p>在src/main/resources目录下新建application.properties文件（此处可新建application.properties或者application.yml文件做配置均可），文件结构如下：</p>\n	</li>\n	<li>\n	<p>#标注服务名称 &nbsp;</p>\n	</li>\n	<li>\n	<p>spring.application.name=add &nbsp;</p>\n	</li>\n	<li>\n	<p>#标注服务端口号 &nbsp;</p>\n	</li>\n	<li>\n	<p>server.port=8083 &nbsp;</p>\n	</li>\n	<li>\n	<p>#配置指向Eureka注册中心的地址 &nbsp;</p>\n	</li>\n	<li>\n	<p>eureka.client.serviceUrl.defaultZone=http://localhost:8080/eureka/ &nbsp;</p>\n	</li>\n	<li>\n	<p>#显示注册客户端主机和端口号 &nbsp;</p>\n	</li>\n	<li>\n	<p>spring.cloud.client.ipAddres=http://localhost/ &nbsp;</p>\n	</li>\n	<li>\n	<p>eureka.instance.instance-id=${spring.cloud.client.ipAddress}:${spring.application.name}:${spring.application.instance_id:${server.port}} &nbsp; &nbsp;</p>\n	</li>\n	<li>\n	<p>eureka.instance.preferIpAddress=true&nbsp;</p>\n	</li>\n	<li>\n	<p>选中ServiceAddApplication右键以Spring Boot App方式启动微服务，访问http://localhost:8080/eurekaUI，发现注册中心已经注册进入了服务，如图3；访问http://localhost:8083/addTwoNum?a=13&amp;b=24，得到计算结果的返回页面，代表微服务注册成功并能正常使用，如图4.</p>\n	</li>\n	<li>\n	<p><img alt=\"3.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523965489044049930.jpg\" /></p>\n	</li>\n	<li>\n	<p><img alt=\"4.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523965503779097539.jpg\" /></p>\n	</li>\n</ol>\n', '0', '0', 'SpringCloud,Java,JF', '', '/Uploads/images/article/2018/12/22/20181222064620.jpg', 'SpringCloud学习记录——Eureka注册中心及serviceAdd微服务', '1');
INSERT INTO `xda_blog_article` VALUES ('6', '2018-12-22 06:48:23', '', '0', null, '1', '将编写的微服务集群部署', 'JustFresh', '0', '<p>点我点我:<a href=\"https://github.com/JustFresh/micro\" target=\"_blank\">项目github地址</a>。</p>\n\n<p>1、multipl服务搭建。</p>\n\n<p>新建maven module，命名为micro-service-multipl，父项目指向micro，打包方式选择jar，新建方式选择&ldquo;maven-archetype-webapp&rdquo;。</p>\n\n<p>pom.xml引入SpringBoot基础包、spring-cloud-starter-eureka、javax.servlet-api，pom.xml依赖包导入（pom其他部分均与Eureka配置中心一致，后续文章不再重复）如图1（代码总乱，没招儿了，看图说话）：</p>\n\n<p><img alt=\"1.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523965860395046141.jpg\" /></p>\n\n<p>在src/main/java目录下新建com.xiudoua.study.micro包，在此包下新建一个ServiceMultiplApplication.java类，其中@SpringBootApplication代表此项目为SpringBoot工程，@EnableDiscoveryClient标注此微服务可被注册中心发现，@ComponentScan注解标注SpringBoot项目的包注解扫描，代码如图2：</p>\n\n<p><img alt=\"2.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523965891302095282.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>图2</p>\n\n<p>在src/main/java目录下新建com.xiudoua.study.micro.controller包，在此包新建MultiplController类，此类提供一个计算a*b之和的服务，代码如图3，其中@Value(&quot;${server.port}&quot;)代表读取application.properties文件的server.port变量值并赋值给当前port变量：</p>\n\n<p><img alt=\"3.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523965930724008664.jpg\" /></p>\n\n<p><br />\n在src/main/resources目录下新建application.properties文件（此处可新建application.properties或者application.yml文件做配置均可），文件结构如下：#标注服务名称 &nbsp;</p>\n\n<p>spring.application.name=multipl &nbsp;</p>\n\n<p>#标注服务端口号 &nbsp;</p>\n\n<p>server.port=8084 &nbsp;</p>\n\n<p>#配置指向Eureka注册中心的地址 &nbsp;</p>\n\n<p>eureka.client.serviceUrl.defaultZone=http://localhost:8080/eureka/ &nbsp;</p>\n\n<p>#显示注册客户端主机和端口号 &nbsp;</p>\n\n<p>spring.cloud.client.ipAddres=http://localhost/ &nbsp;</p>\n\n<p>eureka.instance.instance-id=${spring.cloud.client.ipAddress}:${spring.application.name}:${spring.application.instance_id:${server.port}} &nbsp; &nbsp;</p>\n\n<p>eureka.instance.preferIpAddress=true启动Eureka注册中心、启动multipl服务，访问http://localhost:8080/eurekaUI发现multipl服务注入；访问http://localhost:8084/multiplyTwoNum?a=12&amp;b=21产生计算结果及返回则代表微服务搭建并注册成功。</p>\n\n<p>2、打jar包方式部署、启动。</p>\n\n<p>将Eureka、service-add、service-multipl分别以jar方式进行maven打包，此次测试将打包jar放置在：E:/jar/0404/文件夹下，分别为eureka.jar、service-add.jar、service-multipl1.jar。打开Windows命令行（即dos界面），进入E:/jar/0404/文件夹。以java -jar eureka.jar的方式启动注册中心，同理启动service-add和service-multipl1，启动过程如图4，启动后访问http://localhost:8080/eurekaUI结果如图5&mdash;&mdash;代表服务正常启动并注册到eureka。</p>\n\n<p><img alt=\"4.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966017523061734.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>3、打包部署到tomcat。<img alt=\"5.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966029711010047.jpg\" /></p>\n\n<p>pom.xml文件spring-boot-starter-web依赖出去除内置tomcat依赖&mdash;&mdash;如图6，重写项目启动类&mdash;&mdash;如图7（<a href=\"https://blog.csdn.net/jeffleo/article/details/70880857\" target=\"_blank\">详解请点击这儿</a>）。</p>\n\n<p><img alt=\"6.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966076508002679.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"7.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966087587072939.jpg\" /></p>\n\n<p>PS：SpringBoot1.5.2版本以上面方式打包war部署tomcat既能正常启动，但SpringBoot1.5.9版本得移除内置aspectjweaver，并引入aspectjweaver1.8.7，解决版本冲突，代码如图8：</p>\n\n<p><img alt=\"8.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966120728091315.jpg\" /></p>\n', '0', '0', 'SpringCloud,Java,JF', '', '/Uploads/images/article/2018/12/22/20181222064822.jpg', 'SpringCloud学习记录——multipl服务及jar包war包部署启动', '1');
INSERT INTO `xda_blog_article` VALUES ('7', '2018-12-22 06:49:17', '', '0', null, '1', 'Feign 是一个声明web服务客户端，这便得编写web服务客户端更容易，使用Feign 创建一个接口并对它进行注解，它具有可插拔的注解支持包括Feign注解与JAX-RS注解，Feign还支持可插拔的编码器与解码器，Spring Cloud 增加了对 Spring MVC的注解，Spring Web 默认使用了HttpMessageConverters, Spring Cloud 集成 Ribbon 和 Eureka 提供的负载均衡的HTTP客户端 Feign.', 'JustFresh', '0', '<p>点我点我:<a href=\"https://github.com/JustFresh/micro\" target=\"_blank\">项目github地址</a>。</p>\n\n<p>1、搭建service-feign服务调用multipl（两个节点提供），实现客户端负载均衡效果。</p>\n\n<p>新建maven module，命名为micro-service-feign，父项目指向micro，打包方式选择jar，新建方式选择&ldquo;maven-archetype-webapp&rdquo;。</p>\n\n<p>pom.xml引入SpringBoot基础包、spring-cloud-starter-eureka、javax.servlet-api、，pom.xml依赖包导入：</p>\n\n<p><img alt=\"1.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966375436077233.jpg\" /></p>\n\n<p>在src/main/java目录下新建com.xiudoua.study.micro包，在此包下新建一个FeignApplication.java类，其中@SpringBootApplication代表此项目为SpringBoot工程，@EnableDiscoveryClient标注此微服务可被注册中心发现，@EnableFeignClients为注解此微服务可以通过Feign客户端负载均衡的方式调用其他微服务，代码如图：</p>\n\n<p><img alt=\"2.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966400796052393.jpg\" /></p>\n\n<p>在src/main/java目录下新建com.xiudoua.study.micro.client包，在此包新建MultiplFeignClient接口，用于指向客户端负载均衡调用的微服务（指向微服务serviceId），代码如图：</p>\n\n<p><img alt=\"3.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966427140021572.jpg\" /></p>\n\n<p>在src/main/java目录下新建com.xiudoua.study.micro.controller包，在此包新建FeignController类，此类提供通过Fegin方式调用multipl服务的微服务，代码如图：</p>\n\n<p><img alt=\"4.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966454219080675.jpg\" /></p>\n\n<p>在src/main/resources目录下新建application.properties文件（此处可新建application.properties或者application.yml文件做配置均可），文件结构如下：#标注服务名称 &nbsp;</p>\n\n<p>spring.application.name=feign &nbsp;</p>\n\n<p>#标注服务端口号 &nbsp;</p>\n\n<p>server.port=8087 &nbsp;</p>\n\n<p>#配置指向Eureka注册中心的地址 &nbsp;</p>\n\n<p>eureka.client.serviceUrl.defaultZone=http://localhost:8080/eureka/ &nbsp;</p>\n\n<p>#显示注册客户端主机和端口号 &nbsp;</p>\n\n<p>spring.cloud.client.ipAddres=http://localhost/ &nbsp;</p>\n\n<p>eureka.instance.instance-id=${spring.cloud.client.ipAddress}:${spring.application.name}:${spring.application.instance_id:${server.port}} &nbsp; &nbsp;</p>\n\n<p>eureka.instance.preferIpAddress=true</p>\n\n<p>分别将Eureka打包jar（eureka.jar）、将service-multipl打包为jar（multipl.jar）、将本节service-feign打包jar（feign.jar）,存储到E:/jar/0404/feign文件夹下，如下图所示：</p>\n\n<p><img alt=\"5.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966520954046806.jpg\" /></p>\n\n<p>复制一份multipl.jar命名为multipl2.jar，用360压缩工具打开multipl2.jar（图6），将压缩包中BOOT-INF/classes目录下的application.properties文件拽出来放到当前目录，修改原来端口号为8084为8085（图7），将修改后的application.properties文件覆盖multipl2.jar中BOOT-INF/classes目录下的application.properties文件。</p>\n\n<p><img alt=\"6.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966545017053308.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"7.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966554736052551.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>图7</p>\n\n<p>打开dos窗口，切换到E:/jar/0404/feigin目录，分别启动eureka.jar、multipl.jar、multipl2.jar、feign.jar，访问http://localhost:8080/eurekaUI，访问结果如下图示：</p>\n\n<p><img alt=\"8.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966596862070813.jpg\" /></p>\n\n<p>访问http://localhost:8087/multiplyTwoNum?a=23&amp;b=21，如果页面随机返回&rdquo;访问主机：http://localhost/ 端口：8084 计算结果为：483&ldquo;、&rdquo;访问主机：http://localhost/ 端口：8085 计算结果为：483&ldquo;即代表此乘法计算服务随机由8084或8085端口的微服务提供，客户端负载均衡效果实现。</p>\n\n<p>2、搭建service-feign-hystrix服务调用multipl（两个节点提供），实现客户端负载均衡及断路效果。</p>\n\n<p>注：所谓断路效果，就是指如果微服务挂了不会一直等待后续请求，浪费CPU资源，并且及时返回错误消息，<a href=\"https://blog.csdn.net/forezp/article/details/75333088\" target=\"_blank\">深入了解请点击这儿</a>。</p>\n\n<p>参照步骤1的service-feign项目，新建maven module，项目名为service-feign-hystrix，pom.xml文件相较于步骤1多引入</p>\n\n<p>spring-cloud-starter-hystrix，如下图：</p>\n\n<p><img alt=\"9.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966635097089626.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>服务启动类添加@EnableCircuitBreaker注解，标注此微服务支持断路效果。</p>\n\n<p>在com.xiudoua.study.micro.client包新建HystrixClientFallback类，实现自定义MultiplFeignHystrixClient接口的multiplyTwoNum方法，并在方法返回打印&ldquo;断路器效果成功&rdquo;字样。代码如下图：</p>\n\n<p><img alt=\"10.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966670223014616.jpg\" /></p>\n\n<p>原有MultiplFeignClient接口改为MultiplFeignHystrixClient，代码如下：</p>\n\n<p><img alt=\"11.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966692989090947.jpg\" /></p>\n\n<p>application.properties配置如下：#标注服务名称 &nbsp;</p>\n\n<p>spring.application.name=feign-hystrix &nbsp;</p>\n\n<p>#标注服务端口号 &nbsp;</p>\n\n<p>server.port=8088 &nbsp;</p>\n\n<p>#配置指向Eureka注册中心的地址 &nbsp;</p>\n\n<p>eureka.client.serviceUrl.defaultZone=http://localhost:8080/eureka/ &nbsp;</p>\n\n<p>#显示注册客户端主机和端口号 &nbsp;</p>\n\n<p>spring.cloud.client.ipAddres=http://localhost/ &nbsp;</p>\n\n<p>eureka.instance.instance-id=${spring.cloud.client.ipAddress}:${spring.application.name}:${spring.application.instance_id:${server.port}} &nbsp; &nbsp;</p>\n\n<p>eureka.instance.preferIpAddress=true</p>\n\n<p>打包eureka.jar、multipl.jar、feign-hystrix.jar，分别通过dos以java -jar ***.jar的方式将三个微服务启动，访问http://localhost:8088/multiplyTwoNum?a=23&amp;b=21，如果有正常计算结果返回则代表服务均启动成功；此时关闭multipl服务，再次访问http://localhost:8087/multiplyTwoNum?a=23&amp;b=21，如果页面返回&ldquo;断路器效果成功！&rdquo;，则代表微服务断路器配置成功。</p>\n', '0', '0', 'SpringCloud,Java,JF', '', '/Uploads/images/article/2018/12/22/20181222064915.jpg', 'SpringCloud学习记录——Feign客户端负载均衡及Hystrix断路器', '1');
INSERT INTO `xda_blog_article` VALUES ('8', '2018-12-22 06:53:09', '', '0', null, '1', '路由是微服务体系结构的一个组成部分。例如 / 可以映射到您的Web应用程序，/api/users映射到用户服务，/api/shop映射到商店服务。Zuul是Netflix的基于JVM的开发的路由和服务器端负载均衡器。总之一句话就是：“配置了路由网关，即可将微服务的接口统一通过网关请求、过滤”。', 'JustFresh', '0', '<p>点我点我:<a href=\"https://github.com/JustFresh/micro\" target=\"_blank\">项目github地址</a>。</p>\n\n<p>1、简介。</p>\n\n<p>路由是微服务体系结构的一个组成部分。例如&nbsp;<code>/</code>&nbsp;可以映射到您的Web应用程序，/api/users映射到用户服务，/api/shop映射到商店服务。Zuul是Netflix的基于JVM的开发的路由和服务器端负载均衡器。总之一句话就是：&ldquo;配置了路由网关，即可将微服务的接口统一通过网关请求、过滤&rdquo;。</p>\n\n<p>2、ZUUL项目搭建。</p>\n\n<p>新建maven module，命名为micro-service-zuul，父项目指向micro，打包方式选择jar，新建方式选择&ldquo;maven-archetype-webapp&rdquo;。</p>\n\n<p>pom.xml引入SpringBoot基础包、spring-cloud-starter-eureka、javax.servlet-api，pom.xml依赖包导入、引入ZUUL网关所需依赖spring-cloud-starter-zuul、spring-cloud-zuul-ratelimit，如下图：</p>\n\n<p><img alt=\"1.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966875274040364.jpg\" /></p>\n\n<p>在src/main/java目录下新建com.xiudoua.study.micro包，在此包下新建一个ZuulApplication.java类，main方法添加@SpringCloudApplication（注：并非为@SpringBootApplication）、@EnableZuulProxy、如下图：</p>\n\n<p><img alt=\"2.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523966897524011365.jpg\" /></p>\n\n<p>在src/main/resources目录下新建application.properties文件（此处可新建application.properties或者application.yml文件做配置均可），文件结构如下：#标注服务名称 &nbsp;</p>\n\n<p>spring.application.name=zuul &nbsp;</p>\n\n<p>#标注服务端口号 &nbsp;</p>\n\n<p>server.port=8089 &nbsp;</p>\n\n<p>#配置指向Eureka注册中心的地址 &nbsp;</p>\n\n<p>eureka.client.serviceUrl.defaultZone=http://localhost:8080/eureka/ &nbsp;</p>\n\n<p>#ZUUL指向服务配置 &nbsp;</p>\n\n<p>zuul.routes.apiAdd.path=/apiAdd/** &nbsp;</p>\n\n<p>zuul.routes.apiAdd.serviceId=add &nbsp;</p>\n\n<p>zuul.routes.apiMultiply.path=/apiMultiply/** &nbsp;</p>\n\n<p>zuul.routes.apiMultiply.serviceId=multipl &nbsp;</p>\n\n<p>zuul.routes.apiFeign.path=/apiFeign/** &nbsp;</p>\n\n<p>zuul.routes.apiFeign.serviceId=feign &nbsp;</p>\n\n<p>#显示注册客户端主机和端口号 &nbsp;</p>\n\n<p>spring.cloud.client.ipAddres=http://localhost/ &nbsp;</p>\n\n<p>eureka.instance.instance-id=${spring.cloud.client.ipAddress}:${spring.application.name}:${spring.application.instance_id:${server.port}} &nbsp; &nbsp;</p>\n\n<p>eureka.instance.preferIpAddress=true</p>\n\n<p>注：如上application.properties文件</p>\n\n<p>zuul.routes.apiAdd.path=/apiAdd/** &nbsp;</p>\n\n<p>zuul.routes.apiAdd.serviceId=add</p>\n\n<p>部分代码标注，代表通过zuul网关访问注册中心的add服务，一律以apiAdd匹配。例如add服务本身访问路径为：http://localhost:8083/addTwoNum?a=12&amp;b=5，则通过网关访问即可为：http://localhost:8089/apiAdd/addTwoNum?a=12&amp;b=5 。</p>\n\n<p>3、通过zuul访问service-add、service-multipl、service-feign。</p>\n\n<p>将micro-eureka、micro-service-add、micro-service-multipl（打包并复制修改为multipl.jar、multipl2.jar）、micro-service-feign、micro-service-zuul打jar包放置在E:/jar/0407，如下图:</p>\n\n<p><img alt=\"3.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523967014370035788.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>分别以dos命令（java -jar ***.jar）启动eureka.jar、zuul.jar、add.jar、multipl.jar、multipl2.jar、feign.jar。</p>\n\n<p>预计通过zuul测试访问结构如下：</p>\n\n<p>&nbsp;</p>\n\n<table style=\"width:100%\">\n	<tbody>\n		<tr>\n			<td>微服务</td>\n			<td>直接访问</td>\n			<td>zuul访问</td>\n			<td>返回结果</td>\n		</tr>\n		<tr>\n			<td>add</td>\n			<td>localhost:8083/addTwoNum?a=2&amp;b=5</td>\n			<td>localhost:8089/apiAdd/addTwoNum?a=2&amp;b=5</td>\n			<td>\n			<p>公用调用a+b方法返回</p>\n\n			<p>结果为：7</p>\n			</td>\n		</tr>\n		<tr>\n			<td>multipl</td>\n			<td>\n			<p>localhost:8084/multiplyTwoNum?a=2&amp;b=5</p>\n\n			<p>或者localhost:8085/multiplyTwoNum?a=2&amp;b=5</p>\n			</td>\n			<td>\n			<p>localhost:8089/apiMultipl/addTwoNum?a=2&amp;</p>\n\n			<p>b=5</p>\n			</td>\n			<td>\n			<p>访问主体：http://localhost</p>\n\n			<p>端口：8084 计算结果：10</p>\n\n			<p>或者</p>\n\n			<p>访问主体：http://localhost</p>\n\n			<p>端口：8085 计算结果：10</p>\n			</td>\n		</tr>\n		<tr>\n			<td>feign</td>\n			<td>http://localhost:8087/multiplyTwoNum?a=2&amp;b=5</td>\n			<td>\n			<p>http://localhost:8089/apiFeign/multiplyTwoNum&lsquo;</p>\n\n			<p>?a=2&amp;b=5</p>\n			</td>\n			<td>随机放回：\n			<p>访问主体：http://localhost</p>\n\n			<p>端口：8084/8085 计算结果：10</p>\n\n			<p>&nbsp;</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<p>访问结构图如下：</p>\n\n<p>&nbsp;</p>\n\n<p><img alt=\"4.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523967117544082976.jpg\" /></p>\n\n<p>Eureka注册中心服务注册如下图：</p>\n\n<p><img alt=\"5.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523967145998059438.jpg\" /></p>\n\n<p>分别通过http://localhost:8089/apiAdd/addTowNum?a=2&amp;b=5、http://localhost:8089/apiFeign/multiplTowNum?a=2&amp;b=5、&ldquo;http://localhost:8089/apiFeign/multiplTowNum?a=2&amp;b=5&rdquo;即可测试通过ZUUL网关的访问。</p>\n\n<p>&nbsp;</p>\n', '0', '0', 'SpringCloud,Java,JF', '', '/Uploads/images/article/2018/12/22/20181222065302.jpg', 'SpringCloud学习记录——ZUUL路由网关', '1');
INSERT INTO `xda_blog_article` VALUES ('9', '2018-12-22 06:54:05', '', '0', null, '1', 'Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。（呃呃，讲人话就是：“既然是搞分布式微服务架构，那么随着项目的越来越大，微服务就会越来越多，微服务之间的调用会越来越复杂，比如A调用B、B调用C、C调用D、D又调用A、B....,服务链路追踪的作用就是用图形化web的方式给我们展现服务之间的调用关系”）。', 'JustFresh', '0', '<p>点我点我:<a href=\"https://github.com/JustFresh/micro\" target=\"_blank\">项目github地址</a>。</p>\n\n<p>1、简介。</p>\n\n<p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。（呃呃，讲人话就是：&ldquo;既然是搞分布式微服务架构，那么随着项目的越来越大，微服务就会越来越多，微服务之间的调用会越来越复杂，比如A调用B、B调用C、C调用D、D又调用A、B....,服务链路追踪的作用就是用图形化web的方式给我们展现服务之间的调用关系&rdquo;）。</p>\n\n<p><img alt=\"1.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523967702820056570.jpg\" /></p>\n\n<p>图片来自：https://blog.csdn.net/fend0875/article/details/70314257</p>\n\n<p>2、服务搭建。</p>\n\n<p>&nbsp;</p>\n\n<p>新建maven module，命名为micro-service-zipkin，父项目指向micro，打包方式选择jar，新建方式选择&ldquo;maven-archetype-webapp&rdquo;。</p>\n\n<p>pom.xml引入SpringBoot基础包、spring-cloud-starter-eureka、javax.servlet-api，pom.xml依赖包导入、引入ZUUL网关所需依赖zipkin-server、zipkin-autoconfigure-ui，如下图：</p>\n\n<p><img alt=\"2.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523967727571042345.jpg\" /></p>\n\n<p>在src/main/java目录下新建com.xiudoua.study.micro包，在此包下新建一个ZipkinApplication.java类，main方法添加@SpringBootApplication、@EnableZipkinServer、如下图：</p>\n\n<p><img alt=\"3.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523967756493092208.jpg\" /></p>\n\n<p>在src/main/resources目录下新建application.properties文件（此处可新建application.properties或者application.yml文件做配置均可），文件结构如下：#标注服务名称 &nbsp;</p>\n\n<p>spring.application.name=zipkin &nbsp;</p>\n\n<p>#标注服务端口号 &nbsp;</p>\n\n<p>server.port=8081</p>\n\n<p>启动ZipkinApplication.java，访问<a href=\"http://localhost:8081%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0zipkin%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E4%B8%BB%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A/\">http://localhost:8081即可看到zipkin服务链路追踪主页面，如下图：</a></p>\n\n<p><img alt=\"4.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523967810728078526.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>3、改造已编写服务支持服务链路追踪。</p>\n\n<p>预计达到效果：add&mdash;&mdash;调用&mdash;&mdash;&gt;feign&mdash;&mdash;调用&mdash;&mdash;&gt;multipl.</p>\n\n<p>给add项目、feign项目、multipl项目的pom.xml均添加spring-cloud-sleuth-zipkin引用（添加所需Jar引用），如下图所示：</p>\n\n<p><img alt=\"5.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523967991636082275.jpg\" /></p>\n\n<p>给add项目、feign项目、multipl项目的application.properties均添加如下配置指向zipkin服务链路中心:</p>\n\n<p>#JustFresh 2018-04-02 配置服务链路追踪服务器地址</p>\n\n<p>spring.zipkin.base-url=http://localhost:8081</p>\n\n<p>add项目添加一个CallFeignController.java，代码如下：</p>\n\n<p><img alt=\"6.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523968077528052204.jpg\" /></p>\n\n<p>给feign项目添加一个CallMultiplController.java,代码如下：</p>\n\n<p><img alt=\"7.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523968113763038952.jpg\" /></p>\n\n<p>分别启动eureka、zipkin、add、feign、multipl，访问http://localhost:8083/zipkinCall、http://localhost:8087/zipkinCall。过大概一分钟后访问http://localhost:8081、点击Dependences即可查看到服务间的关系，如下图：</p>\n\n<p><img alt=\"8.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523968147732049724.jpg\" /></p>\n\n<p><img alt=\"9.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523968157357054658.jpg\" /></p>\n', '0', '0', 'SpringCloud,Java,JF', '', '/Uploads/images/article/2018/12/22/20181222065355.jpg', 'SpringCloud学习记录——Sleuth服务链路追踪（Zipkin实现）', '1');
INSERT INTO `xda_blog_article` VALUES ('10', '2018-12-22 06:54:56', '', '0', '2018-12-22 07:03:30', '1', '后端使用SSH+JPA+MySQL，前端使用Thymleaf、layerJS、Bootstrap。亲手教你建立一个SpringCloud下的增删改查Demo.', 'JustFresh', '0', '<p>点我点我:<a href=\"https://github.com/JustFresh/micro\" target=\"_blank\">项目github地址</a>。</p>\n\n<p>1、数据库建表。</p>\n\n<p>新建mysql数据库、取名为springcloudssh，设置编码utf8，执行如下SQL语句创建表。</p>\n\n<p>DROP TABLE IF EXISTS `ssh_user`; &nbsp;</p>\n\n<p>CREATE TABLE `ssh_user` ( &nbsp;</p>\n\n<p>&nbsp; `u_id` varchar(64) NOT NULL, &nbsp;</p>\n\n<p>&nbsp; `username` varchar(100) NOT NULL, &nbsp;</p>\n\n<p>&nbsp; `password` varchar(100) NOT NULL, &nbsp;</p>\n\n<p>&nbsp; `nickname` varchar(255) DEFAULT NULL, &nbsp;</p>\n\n<p>&nbsp; `mobile` varchar(20) DEFAULT NULL, &nbsp;</p>\n\n<p>&nbsp; `gender` varchar(10) DEFAULT NULL, &nbsp;</p>\n\n<p>&nbsp; `email` varchar(50) DEFAULT NULL, &nbsp;</p>\n\n<p>&nbsp; `create_time` datetime NOT NULL, &nbsp;</p>\n\n<p>&nbsp; `u_status` tinyint(2) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;是否启用（1是0否）&#39;, &nbsp;</p>\n\n<p>&nbsp; `address` varchar(255) DEFAULT NULL, &nbsp;</p>\n\n<p>&nbsp; `description` varchar(1000) DEFAULT NULL, &nbsp;</p>\n\n<p>&nbsp; PRIMARY KEY (`u_id`) &nbsp;</p>\n\n<p>) ENGINE=MyISAM DEFAULT CHARSET=utf8;&nbsp;</p>\n\n<p>2、搭建项目并进行配置及分层。</p>\n\n<p>新建maven module，命名为micro-service-jpa，父项目指向micro，打包方式选择jar，新建方式选择&ldquo;maven-archetype-webapp&rdquo;。</p>\n\n<p>pom.xml引入SpringBoot基础包、spring-cloud-starter-eureka、javax.servlet-api，pom.xml依赖导入spring-boot-starter-data-jpa（移除内置hibernate-commons-annotations并重新引用hibernate-commons-annotations&nbsp;4.0.5.Final）、引入spring-boot-starter-thymeleaf&nbsp;spring-boot-starter-thymeleaf模板引擎、引入mysql-connector-java、jdo-api，如下图所示：</p>\n\n<p><img alt=\"1.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523968478580082362.jpg\" /></p>\n\n<p>在src/main/java目录下新建com.xiudoua.study.micro包及其子包、并新建JpaApplication.java作为启动类，新建后结构如下：</p>\n\n<p><img alt=\"2.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523968518581048824.jpg\" /></p>\n\n<p>在src/main/resources目录下新建application.properties文件，文件结构如下：#标注服务名称 &nbsp;</p>\n\n<p>spring.application.name=add &nbsp;</p>\n\n<p>#标注服务端口号 &nbsp;</p>\n\n<p>server.port=8086 &nbsp;</p>\n\n<p>#MySql数据库链接配置 &nbsp;</p>\n\n<p>spring.datasource.url=jdbc:mysql://localhost:3306/springcloudssh?characterEncoding=utf-8 &nbsp;</p>\n\n<p>spring.datasource.username=你MySql数据库账号 &nbsp;</p>\n\n<p>spring.datasource.password=你MySql数据库密码 &nbsp;</p>\n\n<p>spring.datasource.driver-class-name=com.mysql.jdbc.Driver&nbsp;</p>\n\n<p>#指定jpa配置 &nbsp;</p>\n\n<p>spring.jpa.database=mysql &nbsp;</p>\n\n<p>spring.jpa.properties.hibernate.hbm2ddl.auto=update &nbsp;</p>\n\n<p>spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect &nbsp;</p>\n\n<p>spring.jpa.properties.hibernate.show_sql=true &nbsp;</p>\n\n<p>#thymeleaf模板引擎配置 &nbsp;</p>\n\n<p>spring.thymeleaf.mode=HTML5 &nbsp;</p>\n\n<p>spring.mvc.view.prefix=classpath:/templates/ &nbsp;</p>\n\n<p>spring.mvc.view.suffix=.html &nbsp;</p>\n\n<p>#显示注册客户端主机和端口号 &nbsp;</p>\n\n<p>spring.cloud.client.ipAddres=http://localhost/ &nbsp;</p>\n\n<p>eureka.instance.instance-id=${spring.cloud.client.ipAddress}:${spring.application.name}:${spring.application.instance_id:${server.port}} &nbsp; &nbsp;</p>\n\n<p>eureka.instance.preferIpAddress=true &nbsp;</p>\n\n<p>#JustFresh 2018-04-02 配置服务链路追踪服务器地址 &nbsp;</p>\n\n<p>spring.zipkin.base-url=<a href=\"http://localhost:8081/\">http://localhost:8081</a></p>\n\n<p>3、后台增删改查dao、service、controller实现。</p>\n\n<p>com.xiudoua.study.micro.entity包下新建SshUser.java类，对应数据库ssh_user表，代码如下（get、set省略）：import java.io.Serializable; &nbsp;</p>\n\n<p>import java.util.Date; &nbsp;</p>\n\n<p>import javax.persistence.Column; &nbsp;</p>\n\n<p>import javax.persistence.Entity; &nbsp;</p>\n\n<p>import javax.persistence.Table; &nbsp;</p>\n\n<p>@Entity &nbsp;</p>\n\n<p>@Table(name = &quot;ssh_user&quot;) &nbsp;</p>\n\n<p>@SuppressWarnings(&quot;serial&quot;) &nbsp;</p>\n\n<p>public class SshUser implements Serializable{ &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;id&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String id; &nbsp;&nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;username&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String username; &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;password&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String password; &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;nickname&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String nickname; &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;mobile&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String mobile; &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;gender&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String gender; &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;email&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String email; &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;create_time&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private Date createTime; &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;u_status&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private int uStatus; &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;address&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String address; &nbsp;</p>\n\n<p>&nbsp; &nbsp; @Column(name = &quot;description&quot;) &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String description; &nbsp;</p>\n\n<p>}</p>\n\n<p>在com.xiudoua.study.micro.dao目录下新建IUserDao接口，继承JpaRepository（JpaRepository已内置了一系列对数据的增删改查分页等操作，故此dao层方法的使用只需在此基础上添加即可），代码如下：</p>\n\n<p><img alt=\"3.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523968631770002569.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>在com.xiudoua.study.micro.bean目录下新建UserBean.java类，对应SshUser的formbean（此处为测试，直接去除@Entity、@Column等Hibernate注解即可）。</p>\n\n<p>在com.xiudoua.study.micro.exception目录下新建FormException继承Exception（目的为实现表单校验自定义异常，此处仅为个人粗略的设想做法而已，可忽略），代码如下：</p>\n\n<p>&nbsp;</p>\n\n<p>public class FormException extends Exception{ &nbsp;</p>\n\n<p>&nbsp;&nbsp;</p>\n\n<p>&nbsp; &nbsp; private static final long serialVersionUID = 1L; &nbsp;</p>\n\n<p>&nbsp; &nbsp; /**&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;* 错误编码&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;*/ &nbsp;</p>\n\n<p>&nbsp; &nbsp; private String errorCode; &nbsp;</p>\n\n<p>&nbsp; &nbsp; /**&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;* 消息是否为属性文件中的Key&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;*/ &nbsp;</p>\n\n<p>&nbsp; &nbsp; private boolean propertiesKey = true; &nbsp;</p>\n\n<p>&nbsp; &nbsp; /**&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;* 构造一个基本异常.&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;* Creates a new instance of FormException.<br />\n&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;* Description: TODO<br />\n&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;* @param msg&nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp;*/ &nbsp;</p>\n\n<p>&nbsp; &nbsp; public FormException(String msg){ &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; super(msg); &nbsp;</p>\n\n<p>&nbsp; &nbsp; } &nbsp;</p>\n\n<p>&nbsp; &nbsp; public FormException(String errorCode,String msg){ &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; this(errorCode,msg,true); &nbsp;</p>\n\n<p>&nbsp; &nbsp; } &nbsp;</p>\n\n<p>&nbsp; &nbsp; public FormException(String errorCode,String msg,Throwable cause){ &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; this(errorCode, msg, cause, true); &nbsp;</p>\n\n<p>&nbsp; &nbsp; } &nbsp;</p>\n\n<p>&nbsp; &nbsp; public FormException(String errorCode,String msg,boolean propertiesKey){ &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; super(msg); &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; this.setErrorCode(errorCode); &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; this.setPropertiesKey(propertiesKey); &nbsp;</p>\n\n<p>&nbsp; &nbsp; } &nbsp;</p>\n\n<p>&nbsp; &nbsp; public FormException(String errorCode,String msg,Throwable cause,boolean propertiesKey){ &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; super(msg,cause); &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; this.setErrorCode(errorCode); &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; this.setPropertiesKey(propertiesKey); &nbsp;</p>\n\n<p>&nbsp; &nbsp; } &nbsp;</p>\n\n<p>&nbsp; &nbsp; public String getErrorCode() { &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; return errorCode; &nbsp;</p>\n\n<p>&nbsp; &nbsp; } &nbsp;</p>\n\n<p>&nbsp; &nbsp; public void setErrorCode(String errorCode) { &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; this.errorCode = errorCode; &nbsp;</p>\n\n<p>&nbsp; &nbsp; } &nbsp;</p>\n\n<p>&nbsp; &nbsp; public boolean isPropertiesKey() { &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; return propertiesKey; &nbsp;</p>\n\n<p>&nbsp; &nbsp; } &nbsp;</p>\n\n<p>&nbsp; &nbsp; public void setPropertiesKey(boolean propertiesKey) { &nbsp;</p>\n\n<p>&nbsp; &nbsp; &nbsp; &nbsp; this.propertiesKey = propertiesKey; &nbsp;</p>\n\n<p>&nbsp; &nbsp; } &nbsp;</p>\n\n<p>}</p>\n\n<p>在com.xiudoua.study.micro.service目录下新建IBaseService</p>\n\n<p>public interface IBaseService</p>\n\n<p>&nbsp; &nbsp; public int add(T param) throws FormException; &nbsp;</p>\n\n<p>&nbsp; &nbsp; public int remove(T param) throws FormException; &nbsp;</p>\n\n<p>&nbsp; &nbsp; public T update(T param) throws FormException; &nbsp;</p>\n\n<p>&nbsp; &nbsp; public T getOne(T param) throws FormException; &nbsp;</p>\n\n<p>&nbsp; &nbsp; public List</p>\n\n<p>}</p>\n\n<p>在com.xiudoua.study.micro.service新建IUserService</p>\n\n<p><img alt=\"4.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523968978696047275.jpg\" /></p>\n\n<p>在com.xiudoua.study.micro.controller目录下新建UserController.java类，处理用户信息的增删改查控制器、代码如下（此处控制器注解不能使用@RestController，若使用@RestController，则Thymeleaf模板视图不解析）：</p>\n\n<p><img alt=\"5.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523969297731030685.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>4、前端页面实现。</p>\n\n<p>在src/main/resrouces目录下新建public目录（此处引入js、css、images等文件），引入jquery.js、bootstrap.css、layer.js、fontawesome字体样式等，如下图：</p>\n\n<p><img alt=\"6.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523969344435001512.jpg\" /></p>\n\n<p>在src/main/resources目录下新增templates文件夹（此文件夹对应Thymeleaf模板的视图），再此文件夹下新建user文件夹标示user处理，user文件夹下新建add.html、detail.html、list.html、update.html，分别用作用户新增页、用户详情查看页、用户列表页、用户信息修改页，代码分别如下：</p>\n\n<p>（1）、add.html。</p>\n\n<p><img alt=\"7.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523969799222021723.jpg\" /></p>\n\n<p>detail.html</p>\n\n<p><img alt=\"8.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523969849691044368.jpg\" /></p>\n\n<p>update.html</p>\n\n<p><img alt=\"9.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523970540482092567.jpg\" /></p>\n\n<p>list.html</p>\n\n<p><img alt=\"10.jpg\" src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523970767734095769.jpg\" /></p>\n\n<p>&nbsp;</p>\n\n<p>启动JpaApplication.java，访问http://localhost:8086/user/list，即可进行用户增删改查操作，如下图所示：</p>\n\n<p><img src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523970827141097218.jpg\" /></p>\n\n<p><img src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523970827048098790.jpg\" /></p>\n\n<p><img src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523970827063077784.jpg\" /></p>\n\n<p><img src=\"http://www.xiudoua.com/ueditor/jsp/upload/image/20180417/1523970827266071629.jpg\" /></p>\n', '1', '1', 'SpringCloud,Java,JF', '', '/Uploads/images/article/2018/12/22/20181222065455.jpg', 'SpringCloud学习记录——JPA调用数据库（SSH+MySql）的增删改查', '1');
INSERT INTO `xda_blog_article` VALUES ('11', '2018-12-22 06:56:19', '', '0', '2018-12-22 07:02:46', '1', '酸，是青橘吃了一半；酸，是男人无能为力的呐喊；酸，是不孝之人不能长久的陪伴；\n       这酸，似父亲千叮万嘱，满怀期盼；不酸，如恩师敦敦教诲之海纳百川；有点儿酸，叔您恰逢那青春少年之逆叛。别酸，母亲您双眼别酸，孩儿将时来运转，迎幸福美满；怀念这酸，怀念人生道路叔叔阿姨、婶婶伯伯给予的温暖；享受这酸，回味着丹妹的夸赞，小猪的捣蛋，都是亲情的陪伴...', 'JustFresh', '0', '<p>&nbsp; &nbsp; &nbsp; &nbsp;酸，是青橘吃了一半；酸，是男人无能为力的呐喊；酸，是不孝之人不能长久的陪伴；<br />\n&nbsp; &nbsp; &nbsp; &nbsp;这酸，似父亲千叮万嘱，满怀期盼；不酸，如恩师敦敦教诲之海纳百川；有点儿酸，叔您恰逢那青春少年之逆叛。别酸，母亲您双眼别酸，孩儿将时来运转，迎幸福美满；怀念这酸，怀念人生道路叔叔阿姨、婶婶伯伯给予的温暖；享受这酸，回味着丹妹的夸赞，小猪的捣蛋，都是亲情的陪伴...<br />\n&nbsp; &nbsp; &nbsp; 写下这酸，都能想象着老四你调侃我打油诗人的必然；看过这酸，大哥也只是一如既往般淡然，不见内心波澜，可叹可叹；记录这酸，记录着二哥你我本是南北两半，二货要早日幸福美满；提起这酸，提起了我是老三，提到了给骚你加入224的老五，干与不干，你说了不算，成都人民说了算...<br />\n&nbsp; &nbsp; &nbsp; 不必酸，建外的兄弟不必酸，凉都的兄弟你不必酸；艰难道路已前行大半；胸怀、眼界、诚信、努力，成功必然；远在南方的兄弟你不要酸，奔波北方的兄弟你不要酸，生活孤苦，且把回忆作伴...<br />\n&nbsp; &nbsp; &nbsp; 喜欢这酸，喜欢这受虐般勇敢，喜欢回忆的你你你带来的欢笑与不甘，喜欢的是青岛的口感，喜欢的是生活...懒懒。<br />\nPS：酒后之言，纯属胡侃；若有冒失，万望海涵。Happy birthday to&nbsp;&nbsp;Me.</p>\n', '1', '1', '打油诗,JF,生日快乐', '', '/Uploads/images/article/2018/12/22/20181222065616.jpg', '《酸》', '5');
INSERT INTO `xda_blog_article` VALUES ('12', '2018-12-22 06:58:15', '', '0', '2018-12-22 09:18:54', '1', '想要记录些什么，但真的不知道该从何处动笔，从哪儿说起？脑子里总会零星的蹦出几个画面、词句，想要抓住，却难以抓住。感觉本就是最难用文字准确描述，让人永远捉摸不透的东西。此时此刻，只是记录下些许、聊以慰藉的心情而已。那就权当述说一流水账，以“孤单、彷徨”为命题。分做几个篇章（励志工作篇、温暖家庭篇、酸甜苦辣爱情篇、边走边悟生活篇、永不终结篇）逐一说起。', 'JustFresh', '0', '<p><strong>序言：</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;想要记录些什么，但真的不知道该从何处动笔，从哪儿说起？脑子里总会零星的蹦出几个画面、词句，想要抓住，却难以抓住。感觉本就是最难用文字准确描述，让人永远捉摸不透的东西。此时此刻，只是记录下些许、聊以慰藉的心情而已。那就权当述说一流水账，以&ldquo;孤单、彷徨&rdquo;为命题。分做几个篇章（励志工作篇、温暖家庭篇、酸甜苦辣爱情篇、边走边悟生活篇、永不终结篇）逐一说起。</p>\n\n<p><strong>励志工作篇：</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;</strong>&nbsp;今天是2016年12月16日，阴，很冷。算算时间，我已经在当前公司待了一年七个月又五天了，不是很长，但也已然不短。犹记得刚到公司的时候，每个人都不知道IT是什么？程序猿是什么？很茫然。也记得贵阳一帮子同事每天凌晨五点半就要起床往惠水赶、夜里十一二点才回到家里的时候。更记得当初金融街1栋28层的加班、记得28楼的盒饭、记得28楼的老皮、斌哥、小吴敏、小平哥、李胖子、海哥、小明、老罗、老余哥、教主、挖挖机、家门们及同事们......总之真的记得好多好多。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;说起工作篇，就不得不提到两个人，也就是在这两个人的身上，让我越来越觉得人生需要梦想，并不断进步的去实现。这两个人就是刘老板和斌哥。想当初第一次见到老板的时候，那是在4月下旬的一个炎热的下午。我还是短袖短裤的一副程序猿标配扮相，面对高楼大厦、豪车、靓女的怯懦不安；面对工作的不自信（做什么事儿都认为自己不会，纵然是自己最喜欢、最热爱的IT）。时光荏苒，在经历过一段时间的局促不安之后、在和老板接触了多次以后，我相信了梦想，或者说我也开始了以前只敢想而认为自己很难以做的梦想。梦想似山，让人产生征服的动力；梦想如海，总想去看到更远处波澜壮阔的美丽；梦想如风，总能在静滞不动的世界带来活力；梦想就是那划过天际的流星、刹那永恒，总能让我们激动不已。总之，有梦的生活真的很美好、真的很美好、真的很美好......</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;回到正题，如果说刘老板是我人生追梦的同路人的话。那斌哥必然是我人生追梦历程的梦想导师。是斌哥您让我知道了工作不一定要有最完美的解决方案，就怕临到头了没有解决方案；是斌哥您让我体会到了工作永远不会因为你具备什么技能就让你做什么，能做的唯有时刻不断进步、时刻学习用以应变；是斌哥您让我知道寻求解决方案远比实际解决过程重要（人都有依赖性，总希望别人给你谋划了许多，但其实谋划的时候真的很累，所以已经很久都一直讨厌着四个字&ldquo;能者多劳&rdquo;了）；更从斌哥您身上学习感悟到：&ldquo;社会或者环境不可能知道你有什么境遇、有什么难处、有什么不懂不会、有什么迷茫，此时此刻，强者能做到的就是：纵然孤身一人，不要觉得孤单、不必感到彷徨、不焦不躁，去寻求找到自己的方向&rdquo;&mdash;我的方向，追求我想要的&ldquo;品味&rdquo;人生。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;585天过去了，我和很多人一起见证了公司的好与坏。也见到太多人的来来往往。有的人走了，但有的人还坚守着。就像我和几个好友老友说过的一样：&ldquo;每个人无论本性、能力怎样？但坚持和付出本就已然是一件特别美好的事儿，且行且珍惜、多走多包容，大家一起有一个算一个的走着、带着大家的梦一起前进着&rdquo;.......多一份包容，少一点计较。</p>\n\n<p><strong>温暖家庭篇：</strong></p>\n\n<p><strong>&nbsp; &nbsp;&nbsp;</strong>我，91年出生，家里五口人，老爸、老妈、妹妹、弟弟。俺家是农村滴，俺就是农村人，享受不了你们城里人的套路，哈哈！！！从小家庭比较拮据，但最能让我感到温暖幸福的就是，一家子能穷开心的活着、努力着就很好哦（多一点努力，少一点攀比，这能大大的提升幸福感）。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;母亲虽然没读过书，但从小真的教育了我很多东西。是母亲教会了我做人做事得真诚（吃亏是福）；是母亲教会了我做人做事儿得有始有终（老话儿说的有前手得有后手）；也是母亲让我知道，想得多不如做得多，心大也有心大的好处，做了总能有收获；更是母亲让我知道，做人做事尊重是最起码得前提，没有谁会因为金钱、身份、学识、地位等高人一等，也没有谁需要因为感到和别人的差距而觉得低人一等，每个人都是一个脑袋两只胳膊，没有谁比谁多什么少什么，纵然我只喝一块钱的咖啡，而别人喝着高档红酒、洋酒，那又有何妨，我有我自己的品味，不懂的你永远就是不懂，Do you know？？？</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个男人，作为家里的长子。有些事儿，不必多说，也得努力。去年的我做了一年的孝子，和父亲母亲修葺了家里的房子。以后的以后，为了大家庭，也为了我努力追寻的小家庭加油、努力。</p>\n\n<p><strong>酸甜苦辣爱情篇：</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>殚精竭虑、绞尽脑汁的写了这么久，终于写到了爱情篇了。本来本次写东西的初衷主要就是想记录这些，想给自己以后看，更想给你看，想让你了解我，想让你更真切的认识我，但就像和你说过的一样，&ldquo;文字总会被我们下意识的往好的方面描述，唯有面对面真切的声音才能感受到最真实的情感&rdquo;，&ldquo;探索宇宙的真理已经很累了，我没有时间去说谎&rdquo;。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;那么故事该从哪儿说起呢？好吧，那就按先总后分的时间顺序分述！今年关于爱情方面的生活，综述起来就是：&ldquo;如果把每个女生比作男生经历过的一所学校的话，那我就是路过一所名牌大学......清华一样的名牌大学，守望守护着名牌大学，并且差一点就拿到了名牌大学的录取通知书。在这接近一年的守望中，偶尔去买包子的时候遇到了几所中专&rdquo;。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;故事的开始应该从今年的3月份开始，具体的时间是哪天已然忘记了。只记得当时第一眼见到的你：&ldquo;正装、马尾、甜甜的笑容、青春靓丽的气息&rdquo;，那不就是&ldquo;失恋33天的黄小仙&rdquo;、&ldquo;匆匆那年的方茴&rdquo;、&ldquo;山楂树之恋的静秋&rdquo;、&ldquo;我的青春期的李春霞&rdquo;吗？总之那就是你，是那个作为小清新的我无法自拔、不可抗拒的爱上的你。 &nbsp; &nbsp;</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;认识了你之后，每天早上你打卡的时候能偷瞄一眼又缩回眼神而暗自窃喜；时时刻刻都等待着设置了特别提醒的手机振动，qq消息的第一反应先看一看是不是你。是的时候，迅速的想着该怎么回复；不是的时候，又只能埋头叹息。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;写到此处，突然断了很多东西。是因为隔了一天再次提笔，已断了很多东西，很难接续？？？还是因为不敢描绘当初那痛彻心扉的会议；更或者是因为已经陷入了为求读者点赞而描写的误区。我想都不是，一切只是因为对你、对爱还抱有期许，期许你能回心转意，做我的唯一。但这已然背离了我想要叙写这篇文章的初衷（不要孤单，不必彷徨），陷入了泥泞泥藻，难以平息。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;过去的就让它过去吧！我最深爱的姑娘，那些都必然只能成为我们彼此的回忆，又何必强求自己、苦苦的去惋惜；总之，一切的一切就如本来平行的两条直线，不管我再如何弯曲，也最多和你凑个半圆而已，那终究不是圆满，何不早早明智的退一步，不再让彼此都无法喘息，尴尬不已.......</p>\n\n<p><strong>边走边悟生活篇：</strong></p>\n\n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>1、朋友无需太多，有几个无论何时何地都会认为你靠谱的足以。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;人生几十年，生来全身赤裸，死去也就几尺见方的土地而已。朋友无需太多，有几个无论什么情况、何时何地均认为你靠谱的足以（那些不切实际的鼓励，大多来自酒肉朋友，或是远房亲戚）。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;2、活着，就多一点儿体谅。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;活了25年，读书16年，工作2年。发现了一个现象，人都是自私的，特别实在处理关于情绪方面问题的时候，每个人都潜意识希望别人体谅自己。但现实总会让彼此要么分道扬镳、要么从此为敌。只有极少数做到了看开、包容。包容者的圈子会越来越大，因为人们都喜欢和&ldquo;大肚能容&rdquo;的人相处，反之者则就......</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;3、梦想本无贵贱之分，有区分的只是任性。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;以前的自己总认为自己从重点大学毕业，也算是一知识分子了，不愿及不屑和很多人很多事儿为伍。但现实的社会狠狠的抽了我我两耳光，他告诉我，那TMD都是狗屁：&ldquo;梦想本无贵贱之分，人亦无贵贱之分&rdquo;，多学、多做，仅此而已。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;4、学会成熟、学会长大，纵然孤单，也不要彷徨。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;说来可笑，今年最大的收获是重新提起了菜刀，它让我不在愤世嫉俗的为了追梦而烦躁；也提醒我没必要去追寻那本不会有结果的不可靠；更告知了我：&ldquo;人生本就不只是一件事儿，有趣有用的事儿多了去了，亟待你发觉发现，敞开胸怀去拥抱&rdquo;。</p>\n\n<p><strong>永不终结篇：</strong></p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;1、把自己视作一个团队，不愤怒，不抱怨，做自己希望的事儿，做自己认为有意义的事儿，做好自己的&ldquo;秀逗啊&rdquo;。提升自己并分享自己的感悟。</p>\n\n<p>&nbsp; &nbsp; 2、努力追寻自己想要的&ldquo;品味&rdquo;人生。</p>\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;3、找一个和自己有共同人生价值观的人，一起进步。</p>\n', '1', '1', '不要孤单，不必彷徨', '', '/Uploads/images/article/2018/12/22/20181222065800.jpg', '不要孤单，不必彷徨', '5');
INSERT INTO `xda_blog_article` VALUES ('13', '2018-12-22 06:59:32', '', '0', null, '1', '1、JVM内存模型。2、类加载机制。3、什么是Java垃圾回收机制（GC）。4、垃圾回收算法整理。5、各垃圾收集器的优缺点。6、ThreadLocal线程局部变量。7、Java线程池ThreadExecutor。8、Lock关键字。9、Volatile关键字。', 'JustFresh', '0', '<h3><strong>1、JVM内存模型。</strong></h3>\n\n<p><strong>1.1.</strong><strong>程序计数器。</strong></p>\n\n<p>当前线程所执行的字节码的行号指示器。</p>\n\n<p><strong>1.2.Java虚拟机栈。</strong></p>\n\n<p>线程私有，生命周期与线程相同，描述的是Java方法执行的内存模型。</p>\n\n<p><strong>1.3.本地方法栈。</strong></p>\n\n<p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机中使用到的Native方法服务。</p>\n\n<p><strong>1.4.Java堆。</strong></p>\n\n<p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建。</p>\n\n<p><strong>1.5.方法区。</strong></p>\n\n<p>与堆一样，各个线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（运行时常量池）编译后的代码等数据。</p>\n\n<h3>2、类加载机制。</h3>\n\n<p>class文件由类装载器装载后，在JVM中形成一份描述class结构的元信息对象，通过元信息对象可以获知class的结构信息；如构造函数、属性和方法等。Java允许用户借由这个class相关的元信息对象间接调用class对象的功能。</p>\n\n<p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可被虚拟机直接使用的Java类型，这就是类加载机制。</p>\n\n<h3>3、什么是Java垃圾回收机制（GC）。</h3>\n\n<p>在系统运行过程中，会产生一些无用的对象，这些对象占据着一定的内存，如果不对这些对象清理无用的内存，可能会导致内存耗尽，所以垃圾回收机制回收的是内存。同时GC回收的是堆区和方法区的内存。</p>\n\n<h3>4、垃圾回收算法整理。</h3>\n\n<p><strong>4.1.引用计数器算法。</strong></p>\n\n<p>是否有任一地方对对象进行了调用（对象是否已死）。</p>\n\n<p><strong>4.2.可达性分析算法。</strong></p>\n\n<p>选择一个节点作为GC Roots，校验从GC Roots是否可达当前对象（对象是否已死）。</p>\n\n<p><strong>4.3.标记-清除算法。</strong></p>\n\n<p>先标记出待清除对象，再整体进行清除操作。</p>\n\n<p>效率问题，容易产生大量不连续的内存碎片。</p>\n\n<p><strong>4.4.复制算法。</strong></p>\n\n<p>将内存划分为容量等大的两块，当一块用完了，就把还存活着的对象复制到另一块上，然后再把已使用过的内存空间一次性清理掉。</p>\n\n<p><strong>4.5.标记-整理算法。</strong></p>\n\n<p>让所有活着的对象都向一端移动，然后直接清理掉端过界以外的内存。</p>\n\n<p><strong>4.6.分代收集算法。</strong></p>\n\n<p>分别对新生代和老年代的内存进行回收。</p>\n\n<h3>5、各垃圾收集器的优缺点。</h3>\n\n<p><strong>5.1.Serial收集器。</strong></p>\n\n<p><strong>优点：</strong>简单高效，对于限定单个CPU来说，Serial收集器没有现成交互的开销，可专心做垃圾收集以获得最高的单线程收集效率。</p>\n\n<p><strong>缺点：</strong>单线程收集器，在进行垃圾收集时，必须停顿其他所有线程。</p>\n\n<p><strong>5.2.ParNew收集器。</strong></p>\n\n<p>Serial收集器的多线程版本。</p>\n\n<p><strong>5.3.Parallel Scavenge收集器。</strong></p>\n\n<p><strong>吞吐量优先收集器</strong>：使Jvm达到一个可控的吞吐量。</p>\n\n<p>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>\n\n<p><strong>5.4.Serial Old收集器。</strong></p>\n\n<p>Serial收集器的老年代版本，使用标记&mdash;整理算法。</p>\n\n<p><strong>5.5.Paraller Old收集器。</strong></p>\n\n<p>使用多线程和标记&mdash;整理算法收集。</p>\n\n<p><strong>5.6.CMS收集器。</strong></p>\n\n<p>最短回收停顿，采用标记&mdash;清除算法。</p>\n\n<p><strong>优点：</strong>并发收集，低停顿。</p>\n\n<p><strong>缺点：</strong></p>\n\n<p>(a)、CPU资源敏感。</p>\n\n<p>(b)、无法处理浮动垃圾，即无法处理在垃圾收集过程中产生的新垃圾。</p>\n\n<p>(c)、容易产生空间碎片。</p>\n\n<p><strong>5.7.G1收集器。</strong></p>\n\n<p>并发与并行、分代收集、空间整合、可预测的停顿</p>\n\n<h3><strong>6、ThreadLocal线程局部变量。</strong></h3>\n\n<p>所谓线程局部变量，就是仅仅能被本线程访问，不能在线程之间共享的变量。</p>\n\n<p><strong>synchronized</strong>用于县城之间的数据共享（使变量或者代码块在某一时刻只能被一个线程访问），是一种延长访问时间来换取线程安全的策略。</p>\n\n<p><strong>ThreadLocal</strong>用于线程间的数据隔离（为每一个线程都提供了变量的副本），是一种以空间来换取线程安全的策略。</p>\n\n<h3><strong>7、Java线程池ThreadExecutor。</strong></h3>\n\n<p><strong>线程池</strong>：一种多线程的处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。</p>\n\n<p>线程池线程都是后台线程，每个线程都是用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。</p>\n\n<p>corePoolSize：核心线程池大小</p>\n\n<p>maximumPoolSize：最大线程池大小</p>\n\n<p>workQueue：阻塞任务队列</p>\n\n<p>threadFactory：新建线程工厂</p>\n\n<p>keepAliveTime：线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使核心线程有效时间。</p>\n\n<p>TimeUnit：keepAliveTime的单位。</p>\n\n<p><strong>注意：</strong></p>\n\n<p>（a）、当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</p>\n\n<p>（b）、当线程池达到corePoolSize时，新提交的任务被放入workQueue中，等待线程池中任务调度执行。</p>\n\n<p>（c）、当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交的任务会创建新线程执行任务。</p>\n\n<p>（d）、当提交任务超过maximumPoolSize时，新提交的任务由RejectedExecutionHandler处理。</p>\n\n<p>（e）、当线程池中超过corePoolSize，空闲时间达到keepAliveTime时，关闭空闲线程。</p>\n\n<p>（f）、当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭。</p>\n\n<h3>8、Lock关键字。</h3>\n\n<p>Synchronized关键字是Java语言内置关键字，Lock是一个类，通过这个类可以实现同步访问。</p>\n\n<p>Synchronized不需要用户手动去释放锁，当Synchronized方法或者代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能出现死锁现象。</p>\n\n<p>一般来说，使用Lock必须在try{}catch{}finally{}中执行，并且将释放锁的操作放在finally块中执行，以保证锁一定会被释放，防止死锁发生。</p>\n\n<h3>9、Volatile关键字。</h3>\n\n<p>保证不同线程对这个变量进行的操作时的可见性，所有线程都能看到共享内存的最新状态。</p>\n\n<p>Java通过以下几种原子性操作完成工作内存和主内存的交互：</p>\n\n<p>（a）、lock：作用于主内存，把变量标识为线程独占状态。</p>\n\n<p>（b）、unlock：解除独占状态。</p>\n\n<p>（c）、read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。</p>\n\n<p>（d）、load：作用工作内存，把read操作传过来的变量值放入工作内存的变量副本中。</p>\n\n<p>（e）、use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。</p>\n\n<p>（f）、assign：作用工作内存，把一个从执行引擎接收到的值赋给工作内存的变量。</p>\n\n<p>（g）、store：作用于工作内存的变量，把工作内存的一个变量值传送到主内存中。</p>\n\n<p>（h）、write：作用于主内存的变量，把store操作传来的变量放入主内存的变量中。</p>\n\n<p>Volatitle是如何保持内存的可见性？</p>\n\n<p>read、load、use动作必须连续出现。</p>\n\n<p>assign、store、write动作必须连续出现。</p>\n\n<p>使用volatitle关键字能够保证：</p>\n\n<p>每次读前必须从主内存刷新最新的值。</p>\n\n<p>每次写入后必须立即同步到主内存中。</p>\n\n<p>总结：volatitle关键字修饰的变量看到的随时是自己的最新值。</p>\n', '0', '0', 'Java,面试', '', '/Uploads/images/article/2018/12/22/20181222065930.jpg', 'Java相关知识点整理《一》', '1');
INSERT INTO `xda_blog_article` VALUES ('14', '2018-12-22 07:00:53', '', '0', '2018-12-22 07:03:18', '1', '10、AtomicInteger类。11、Java常用集合。12、服务端的几种IO模型。13、NIO相关知识。14、SpringMVC工作原理解析。15、MyBatis的实现。16、数据库索引类型。17、MySQL三种数据引擎比较。18、Redis相关知识。', 'JustFresh', '0', '<h3>10、AtomicInteger类。</h3>\n\n<p>AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减，十分适合高并发情况下的使用，AtomicInteger是在使用非阻塞算法实现并发控制。</p>\n\n<h3>11、Java常用集合。</h3>\n\n<p>Collection和Map，是集合框架的根接口。</p>\n\n<p>Set:接口：实现类有HashSet和LinkedHashSet。Set的子接口SortedSet接口&mdash;&mdash;&gt;实现类：TreeSet。</p>\n\n<p>List:接口：实现类有LinkedList、Vector、ArrayList。</p>\n\n<p>Vector：可实现自动增长的对象数组，重量级、线程安全、使用少。</p>\n\n<p>ArrayList：底层是Object数组，所以ArrayList具有数组的查询速度快的优点以及增删速度慢的缺点。</p>\n\n<p>LinkedList：采用双向循环链表实现，方便增删，不利于查询。</p>\n\n<p>HashSet通过equals和HashCode来判断两个元素是否相等，具体规则是：如果两个元素通过equals比较为true，并且两个元素的HashCode相等，则两个元素重复。</p>\n\n<p>Map集合比较：</p>\n\n<p>HashMap的存入顺序和输出顺序无关。</p>\n\n<p>LinkedHashMap保留了键值对的存入顺序。</p>\n\n<p>TreeMap则是对Map中的元素进行排序。</p>\n\n<p>HashMap和HashTable的比较：</p>\n\n<p>（a）、都是Java集合类，都可以用来存放Java对象。</p>\n\n<p>（b）、HashTable 是Java1.1就有的，HashMap是Java1.2引进的Map接口的一个实现。</p>\n\n<p>（c）、HashTable是同步的，这个类中的一些方法会保证HashTable中的对象是线程安全的；HashMap是异步的，HashMap中的对象不是线程安全的。</p>\n\n<p>（d）、HashMap的key或value可放入空值（null）而HashTable不可以。</p>\n\n<p>总结：</p>\n\n<p>如果要求线程安全，使用Vector、HashTable。</p>\n\n<p>如果不要求线程安全，使用ArrayList、LinkedList、HashMap。</p>\n\n<p>如果要求键值对，则使用HashMap、HashTable。</p>\n\n<p>如果数据量很大，又要求线程安全考虑Vector。</p>\n\n<h3>12、<strong>服务端的几种IO模型。</strong></h3>\n\n<p><strong>12.1.阻塞式模型。</strong></p>\n\n<p>指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错才返回。</p>\n\n<p><strong>12.2.多线程的服务模型（异步IO）。</strong></p>\n\n<p>目的是让每个连接都有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。</p>\n\n<p><strong>12.3.非阻塞式模型。</strong></p>\n\n<p>非阻塞IO通过进程反复调用IO函数，与阻塞不同的是，调用IO函数后，内核会立刻返回一个错误的接口，该进程会不断去调用查询结果的函数recv（），直到收到正确的结果，在这个过程中进程是阻塞的。</p>\n\n<p><strong>12.4.IO复用模型。</strong></p>\n\n<p>关键来自select/epoll这个Function，对一个IO端口，两次调用，两次返回。好处在于单个process可以同时处理多个网络连接的IO。</p>\n\n<p><strong>12.5.信号驱动IO。</strong></p>\n\n<p>首先允许套接字进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用IO操作函数处理数据。</p>\n\n<h3>13、NIO相关知识。</h3>\n\n<p>传统IO</p>\n\n<p>NIO&mdash;&gt;非阻塞式IO</p>\n\n<p>AIO&mdash;&gt;异步IO</p>\n\n<p>NIO关键点：</p>\n\n<p><strong>（a）、&nbsp;缓冲区Buffer。</strong></p>\n\n<p>一个Buffer对象是固定数量的数据的容器。其作用是一个存储器，或者分段运输区，在这里数据可被存储并在之后用于检索。</p>\n\n<p><strong>（b）、通道Channel。</strong></p>\n\n<p>通道是一种途径，可以用最小的总开销来访问操作系统本身的IO服务。通道可以是单向的或者双向的。</p>\n\n<p><strong>（c）、选择器Selector。</strong></p>\n\n<p>用于分发不同的请求到不同的Channel，这样才能确保Channel不处于阻塞状态就可以收发消息。</p>\n\n<p><strong>（d）、图示。</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://img-blog.csdn.net/2018100216233792?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0NTk4NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></strong></p>\n\n<h3>14、SpringMVC工作原理解析。</h3>\n\n<p><strong>14.1.SpringMVC处理流程。</strong></p>\n\n<p>（a）、用户发送请求至前端控制器DispatcherServlet。</p>\n\n<p>（b）、DispatcherServlet收到请求调用handlerMapping处理器映射器。</p>\n\n<p>（c）、处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找）、生成处理器对象及处理器拦截器（如果有则生辰）一并返回给DispatcherServlet。</p>\n\n<p>（d）、DispatcherServlet调用HandlerAdapter处理器适配器。</p>\n\n<p>（e）、HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）。</p>\n\n<p>（f）、Controller执行完后返回ModeAndView。</p>\n\n<p>（g）、HandlerAdapter将Controller执行结果ModelAndView返回DispatcherServlet。</p>\n\n<p>（h）、DispatcherServlet将ModeAndView传给ViewResolver视图解析器。</p>\n\n<p>（i）、ViewReslver解析返回具体的View。</p>\n\n<p>（j）、DispatcherServlet根据View渲染视图并响应用户。</p>\n\n<p><strong>14.2.HandlerMapping简述。</strong></p>\n\n<p>项目启动时通过HandlerMap将Controller的url映射为一个Map，用户请求访问时，用当前url与map中的数据做比对，并返回对应的Handler。</p>\n\n<p><strong>14.3.HandlerAdapter简述。</strong></p>\n\n<p>SpringMVC通过HandlerAdapter来实际调用处理函数。</p>\n\n<h3>15、MyBatis的实现。</h3>\n\n<p><strong>15.1.MyBatis的初始化。</strong></p>\n\n<p>MyBatis的初始化其实过程其实就是解析配置文件和初始化Configuration的过程。首先创建SQLSessionFactory创建者对象，然后由它进行创建SessionFactory，这里用到的是建造者模式，建造者模式最简单的理解就是不手动new对象，而是由其他类来进行对象的创建。然后由SQLSessionFactory来创建SqlSession对象。</p>\n\n<p><strong>15.2.MyBatis的SQL查询流程。</strong></p>\n\n<p>SQL查询参数设置：首先获取数据库connection连接，然后准备statement，然后设置SQL查询中的参数值。打开一个connection连接，在使用完后不会close，而是存储下来，当下次需要打开时直接返回。</p>\n\n<p>SQL查询结果集的封装：ResultSetWrapper是ResultSet的封装类，调用getFirstResultSet方法获取第一个ResultSet，同时获取数据库的metaData数据，包括数据表列名、列的类型、类序号等，这些信息都存储在ResultSetWrapper类中了，然后调用HandleResultSet方法来进行结果集的封装。</p>\n\n<p><strong>15.3.MyBatis缓存。</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://img-blog.csdn.net/20181002163140398?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0NTk4NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></strong></p>\n\n<p>一级缓存是SqlSession级别的缓存，每个SqlSession对象都有一个哈希表用于缓存数据，不同SqlSession对象之间缓存不共享。同一个SqlSession对象执行两遍相同的Sql查询，在第一次查询完毕后会将查询结果缓存起来，第二遍查询直接返回结果即可，MyBatis默认是开启一级缓存的。</p>\n\n<p>二级缓存是Mapper级别的缓存，二级缓存是跨SqlSession的，多个SqlSession对象可以共享同一个二级缓存。MyBatis默认是不开启二级缓存的，可以配置开启二级缓存（CacheEnabled）。</p>\n\n<p><strong>16、数据库索引类型。</strong></p>\n\n<p>（a）、普通索引。</p>\n\n<p>（b）、唯一索引。</p>\n\n<p>（c）、主键索引。</p>\n\n<p>（d）、聚集索引。</p>\n\n<p>该索引中键值的逻辑顺序决定表中相应的物理顺序。</p>\n\n<p>（e）、非聚集索引。</p>\n\n<p>该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p>\n\n<h3>17、MySQL三种数据引擎比较。</h3>\n\n<p><strong>17.1.InnoDB。</strong></p>\n\n<p>支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那么选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（Commit）和回滚（RollBack）。</p>\n\n<p><strong>17.2.MyISAM。</strong></p>\n\n<p>插入数据快，空间和内存使用比较低。如果表主要用于插入新记录和读出记录。那么选择MyISAM能实现处理的高效率。如果应用的完整性、并发性要求比较低，也可以使用。</p>\n\n<p><strong>17.3.MEMORY。</strong></p>\n\n<p>所有的数据都在内存中，数据处理速度快，但是安全性不够高。如果需要很快的读写速度，对数据的安全性要求比较低，可以选择MEMORY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p>\n\n<h3>18、<strong>Redis相关知识。</strong></h3>\n\n<p><strong>18.1.使用场景。</strong></p>\n\n<p>（a）、配合关系型数据库做告诉缓存。</p>\n\n<p>缓存高频次访问的数据，降低数据库IO。</p>\n\n<p>分布式架构做Session共享。</p>\n\n<p>（b）、可以持久化特定数据。</p>\n\n<p>利用ZSet类型可以存储排行榜。</p>\n\n<p>利用list的自然时间排序存储最新n个数据。</p>\n\n<p><strong>18.2.使用Redis的好处。</strong></p>\n\n<p>（a）速度快，因为数据存储在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O（1）。</p>\n\n<p>（b）支持丰富的数据类型，支持String、list、set、sorted set（ZSet）、Hash。</p>\n\n<p>（c）支持事务，操作都是原子性。所谓的原子性就是对数据的更改要么全部执行，要么全部不执行。</p>\n\n<p>（d）丰富的特性：可用于缓存、消息队列、按key设置过期时间，过期后自动删除。</p>\n\n<p><strong>18.3.Redis缓存击穿问题处理。</strong></p>\n\n<p>缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，致使数据库异常。</p>\n\n<p>（a）使用互斥锁排队。</p>\n\n<p>根据key获取对应的value值为空时，锁上，从数据库中load数据后再释放锁（分布式环境需要使用分布式锁，单机环境的话使用Synchronized、Lock即可）。</p>\n\n<p>（b）BloomFilter布隆过滤器。</p>\n\n<p>类似于一个HashSet，用于判断某个元素是否存在于集合中。</p>\n\n<p><strong>18.4.Redis缓存雪崩问题处理。</strong></p>\n\n<p>缓存在同一时间内大量过期（失效），接着来的一大波请求瞬间落在数据库上导致连接异常。</p>\n\n<p>（a）互斥锁排队（处理同上）。</p>\n\n<p>（b）建立缓存备份。</p>\n\n<p>缓存A和缓存B，B不设置超时时间，先从A读缓存，A没有则读B，并且更新A缓存和B缓存。</p>\n', '1', '0', 'Java,面试', '', '/Uploads/images/article/2018/12/22/20181222070051.jpg', 'Java相关知识点整理《二》', '1');
INSERT INTO `xda_blog_article` VALUES ('15', '2018-12-22 07:02:09', '', '0', '2018-12-22 07:03:10', '1', '19、6种常见的负载均衡算法。20、Zuul相关知识。21、Eureka与Zookeeper的对比。22、Kafka学习记录。23、分布式Session解决方案。24.分布式事务解决方案。25.分布式锁解决方案。26.Ribbon负载均衡相关知识。27.Spring Security相关知识。28.Oauth2的相关知识。', 'JustFresh', '0', '<h3>19、6<strong>种常见的负载均衡算法。</strong></h3>\n\n<p><strong>19.1..轮询法。</strong></p>\n\n<p>请求按顺序轮流分配到后端服务器，而不关心服务器连接数和负载能力。</p>\n\n<p><strong>19.2.随机算法。</strong></p>\n\n<p><strong>19.3.源地址哈希算法。</strong></p>\n\n<p>获取客户端IP，哈希计算后得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客户端要访问的服务器编号。</p>\n\n<p><strong>19.4.加权轮询算法。</strong></p>\n\n<p><strong>19.5.加权随机算法。</strong></p>\n\n<p><strong>19.6.最小连接数算法。</strong></p>\n\n<p>请求总是转发到连接数最小的服务器上。</p>\n\n<h3>20、<strong>Zuul相关知识。</strong></h3>\n\n<p>Zuul提供了一个框架，可以对过滤器进行动态的加载、编译、运行。</p>\n\n<p>Zuul过滤器之间没有直接的相互通信，他们之间通过一个RequestContext的静态类来进行数据的传递。RequestContext类中有ThreadLocal变量来记录每个Request所需传递的数据。使用ThreadLocal达到线程安全目的。</p>\n\n<p><strong>20.1.Zuul四种过滤器类型。</strong></p>\n\n<p>（a）RRE：前置过滤器，这种过滤器在请求被路由之前调用。</p>\n\n<p>（b）ROUTING：这种过滤器将请求路由到微服务，使用Apache HTTPClient或者Netflix Ribbon请求微服务。</p>\n\n<p>（c）POST：这种过滤器在路由到微服务以后执行。</p>\n\n<p>（d）ERROR：其他阶段发生错误时执行该过滤器。</p>\n\n<p><strong>20.2.Zuul两种内置特殊过滤器。</strong></p>\n\n<p>StaticResponseFilter：允许Zuul本身生成响应，而不是请求转发到源。</p>\n\n<p>SurgicalCycleFilter：允许将特定请求路由到分隔的调试集群和主机。</p>\n\n<p><strong>20.3.ContextLifeCycleFilter到RequestContext的生命周期管理。</strong></p>\n\n<p>ContextLifeCycleFilter的核心功能是为了清除RequestContext；请求上下文RequestContext通过ThreadLocal存储，需要在请求完毕后删除该对象。RequestContext提供了执行filter Pipeline所需的Context，因为Servlet是单列多线程，这就要求RequestContext既要线程安全又要Request安全。Context使用ThreadLocal保存，这样每个worker线程都有一个与其绑定的RequestContext，因为worker仅能同时处理一个Request，这就保证了RequestContext既是线程安全的又是Request安全的。</p>\n\n<h3>21、<strong>Eureka与Zookeeper的对比。</strong></h3>\n\n<p>分布式CAP理论：</p>\n\n<p>C一致性、A可用性、P分区容错性</p>\n\n<p>Zookeeper：基于CP，不保证高可用，如果Zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获取数据。</p>\n\n<p>Eureka：基于AP，能保证高可用，即使所有的机器挂了，也能拿到本地缓存的数据。</p>\n\n<h3>22、<strong>Kafka学习记录。</strong></h3>\n\n<p>在一个可配置的时间段内，Kafka集群内保留所有发布的消息，不管这些消息有没有被消费。比如，如果消息的保存策略被设置为两天，那么在一个消息被发布的两天内，它都是可以被消费的。之后它将被丢弃以释放空间。Kafka的性能是和数据量无关的常量级的，所以保留太多的数据并不是问题。</p>\n\n<p>消息发布的两种模式：</p>\n\n<p>（1）队列模式（queuing）。</p>\n\n<p>Consumers可以同时从服务端读取消息，每个消息只被其中的一个customer读取到。</p>\n\n<p>（2）发布&mdash;订阅模式（publish&mdash;subscribe）。</p>\n\n<p>消息被广播到所有的consumer中。Consumers可以加入一个consumer组，共同竞争同一个topic，topic的消息将被分发到组中的一个成员中。同一组的consumer可以在不同程序中，也可以在不同机器上。</p>\n\n<p>注：如果所有的consumer都在一个组上，就成为了传统的队列模式，在各consumer中实现负载均衡。如果所有的consumer都在不同的组上，就成为了发布&mdash;订阅模式。</p>\n\n<p>注：consumer组的消费数量不能多于分区的数量，也就是有多少分区就允许有多少并发消费。</p>\n\n<p>Kafka只能保证一个分区之内的消息的有序性，在不同的分区之间是不可以的，这已经可以满足了大部分应用的需求，如果需要topic中所有消息的有序性，那就只能让这个topic只有一个分区，当然也就只有一个consumer组消费它。</p>\n\n<p>Producer直接将数据发送到broker的leader（主节点），不需要再多个节点进行分发。为了帮助producer做到这点，所有的kafka都可以及时的告知：哪些节点是活动的？目标topic、目标分区的leader在哪儿。这样producer就可以直接将消息发送到目的地了。</p>\n\n<p>Producer将消息推送到broker，consumer从broker拉取消息。</p>\n\n<p>Kafka生产者不能从代码上生成topic，只有在服务器上用命令生成。</p>\n\n<h3><strong>23、分布式Session解决方案。</strong></h3>\n\n<p><strong>23.1.Session复制。</strong></p>\n\n<p>Tomcat、Jetty服务器等自带，配置即可。</p>\n\n<p>使用场景：机器较少，网络流量较少。</p>\n\n<p>缺点：广播式复制到其余机器有一定延时，带来一定的网络开销。</p>\n\n<p><strong>23.2.客户端Cookie存储Session。</strong></p>\n\n<p>缺点：每次那个请求都携带Session，占网络带宽；存储大小收到cookie大小限制；网络传输存在安全隐患。</p>\n\n<p><strong>23.3.反向代理Nginx。</strong></p>\n\n<p>外载一层Nginx，反向代理使用用户IP做hash，以保证每一个IP的请求落在同一台web-server上。</p>\n\n<p><strong>23.4.集中式缓存处理。</strong></p>\n\n<p>Redis集群存储，Spring Session存储Redis。</p>\n\n<p>使用场景：集群中机器数量较多，网络环境复杂。</p>\n\n<p>缺点：实现复杂，稳定性依赖于缓存的稳定性，Session信息放入缓存时要有合理的策略写入。</p>\n\n<h3>24.<strong>分布式事务解决方案。</strong></h3>\n\n<p><strong>24.1.两阶段提交（2PC）。</strong></p>\n\n<p>增设事务协调器（TC）处理控制事务节点事务。</p>\n\n<p>缺点：多次节点之间的网络通信，通信时间较长。</p>\n\n<p>锁定资源时间长。</p>\n\n<p>不适宜高并发场景。</p>\n\n<p><strong>24.2.补偿机制（TCC）。</strong></p>\n\n<p>事务链中的任一操作。都对应一个符合回滚规则的逆向操作；若事务链的任何操作失败，则分别调用各已被正向操作的回滚操作，进行事务回滚。</p>\n\n<p><strong>24.3.本地消息表（MQ异步确保）。</strong></p>\n\n<p>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理。</p>\n\n<p><img alt=\"\" src=\"https://img-blog.csdn.net/20181002170318741?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0NTk4NzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>\n\n<p>消息生产方：需要额外新建一个消息表，并记录消息发送状态。消息表和业务数据要在同一个事务里提交，也就是说他们要存储在同一个数据库里面。然后消息会经过MQ发送到消费方。如果消息发送失败，进行消息重试机制。</p>\n\n<p>消息消费方：需要处理这个消息，完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么会进行重试机制。如果业务上处理失败，可以给生产方发送一个业务补偿消息，通知生产方进行业务回滚。</p>\n\n<p>生产方和消费方定时扫描本地消息表，把还没有处理完成的消息或者发送失败的消息再发送一遍。</p>\n\n<h3>25.<strong>分布式锁解决方案。</strong></h3>\n\n<p>分布式锁：保证一个方法在同一时间内只能被同一个线程执行。</p>\n\n<p><strong>25.1.基于数据库实现分布式锁。</strong></p>\n\n<p>直接创建一张锁表，然后通过操作该表中的数据来实现。当我们要锁住某个方法和资源时，就在该表中增加一条记录，想要释放锁是删除此记录即可。</p>\n\n<p>基于数据库的排他锁来实现分布式锁（在查询语句后加上&ldquo;for update&rdquo;，数据库存储method_name需要创建唯一索引）。</p>\n\n<p><strong>25.2.基于缓存实现分布式锁。</strong></p>\n\n<pre>\nString result=jedis.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>lockKey：获取锁的唯一key。</p>\n\n<p>requestId：调用客户端通过UUID.randomUUID().toString()生成requestId并传递给被调用资源，这就把资源和客户端绑定，在解锁的时候就有对应依据。</p>\n\n<p>expireTime：过期时间，过期自动释放锁。</p>\n\n<p>实现思想：</p>\n\n<p>（a）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动解锁。锁的value值为一个随机生成的UUID，通过此在解锁的时候进行判断。</p>\n\n<p>（b）获取锁的时候还设置一个获取的超时时间，若超过这个时间则自动放弃获取锁。</p>\n\n<p>（c）释放锁的时候，通过UUID判断是不是该锁，若是该锁则执行delete进行锁释放。</p>\n\n<p><strong>25.3.基于Zookeeper实现分布式锁。</strong></p>\n\n<p>当每个客户端对某个资源加锁时，在Zookeeper上的与该方法对应的指定节点目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只要判断当前客户端创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听子节点变更消息，获得子节点变更通知后重复此步骤直至获得锁。完成业务流程后，删除对应的子节点释放锁。</p>\n\n<h3>26.<strong>Ribbon负载均衡相关知识。</strong></h3>\n\n<p>Ribbon是Netflix公司开源的一个负载均衡项目，它属于客户端负载均衡器，Feign已经默认使用了Ribbon（Zuul使用Ribbon做负载均衡器，默认采用轮询算法）。</p>\n\n<p>LoadBalancerClient的实现类为RibbonLoadBalancerClient，它是最终的负载均衡处理执行器。</p>\n\n<p>IRule用做负载均衡的策略，它有三个方法，其中choose()是根据key来获取Server，setLoadBalancer()和getLoadBanlancer()是用来设置和获取ILoadBalance的。</p>\n\n<p>Ribbon提供了如下七种负载均衡策略：</p>\n\n<p>（a）BestAvailableRule：选择一个最小并发请求的Server。</p>\n\n<p>（b）AvailabilityFilteringRule：过滤掉那些高并发的后端Server（active connections超过配置的阀值）。</p>\n\n<p>（c）WeightedResponseTimerRule：根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。</p>\n\n<p>（d）RetryRule：对选定的负载均衡策略机上重试机制。</p>\n\n<p>（e）RoundRobinRule：轮询式选择Server（默认机制）。</p>\n\n<p>（f）RandomRule：随机选择一个Server响应。</p>\n\n<p>（g）ZoneAvoidancdRule：符合判断server所在区域的性能和server的可用性选择server。</p>\n\n<p>application.properties配置随机访问的示例：</p>\n\n<pre>\nservice-B.ribbon.NFLoadBalancerRuleClassName=com.netflix.loadBalancer.RandomRule\n</pre>\n\n<p>&nbsp;</p>\n\n<h3>27.<strong>Spring Security相关知识。</strong></h3>\n\n<p>Spring Security就是引入一系列的SecurityFilter，将其添加到Spring中去了；在有请求时，根据URL是否符合每个Filter的规则来判断是否需要该Filter来进行处理。</p>\n\n<p>几个核心组件：</p>\n\n<p>（a）SecurityContextHolder。</p>\n\n<p>用于存储Security Context，主要是当前回话的Principal，默认是使用ThreadLocal来存放这些信息（线程安全）；常用于获取当前用户的相关信息，Spring Security使用Authentication来封装这些信息。</p>\n\n<p>（b）UserDetails、Principal、Authentication。</p>\n\n<p>Spring Security中使用Authentication存储当前用户的主要信息。Authentication中存储的是Principal，与UserDetails直接可以强制转换。UserDetails主要用于存储用户名、密码、权限列表等信息。Spring Security提供了一个UserDetailService接口，该接口用于查询并返回一个UserDetails，实现该接口的loadByUsername方法，查询当前用户及用户对权限列表存储返回。</p>\n\n<p>（c）GrantedAuthority。</p>\n\n<p>Authentication对象除了getPrincipal()方法调用返回用户基本信息外，还有getAuthorities()方法可以返回List</p>\n\n<p>Spring Security的认证授权实现：</p>\n\n<p>（1）首先需要一个认证管理器AuthenticationManager，他将注册一个ProviderManager示例；</p>\n\n<p>（2）其次要注册一个或多个认证provider，即相关的认证逻辑，认证管理器会依次执行这些provider。</p>\n\n<p>（3）这些provider执行之后认证管理器将返回一个完整的Authentication对象或者认证失败的异常。</p>\n\n<p>（4）假设（3）中的认证成功之后，Authentication将会保存到Spring Context中，之后该用户的访问，都会根据Authentication中的List</p>\n\n<h3>28.Oauth2的相关知识。</h3>\n\n<p>Oauth在&ldquo;客户端&rdquo;与&ldquo;服务器提供商&rdquo;之间，设置了一个授权层。&ldquo;客户端&rdquo;不能直接登录&ldquo;服务器提供商&rdquo;，只能登录授权层，以此将用户与客户端区分开来。&ldquo;客户端&rdquo;登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的授权范围和有效期。</p>\n\n<p>Oauth2有如下四种授权模式：</p>\n\n<p><strong>（1）授权码模式。</strong></p>\n\n<p>（a）用户访问客户端，后者将前者导向认证服务器。</p>\n\n<p>（b）用户选择是否给予客户端授权。</p>\n\n<p>（c）假设用户给予授权，授权服务器将用户导向客户端事先指定的&ldquo;重定向URI&rdquo;，同时附上一个授权码。</p>\n\n<p>（d）客户端收到授权码，附上早先的&ldquo;重定向URI&rdquo;，向认证服务器申请令牌。这一步是在客户端的后台服务器上完成的，对用户不可见。</p>\n\n<p>（e）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access_token）和更新令牌（refresh_token）。</p>\n\n<p><strong>（2）简化模式。</strong></p>\n\n<p>简化模式不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了授权码这个步骤。</p>\n\n<p><strong>（3）密码模式。</strong></p>\n\n<p>用户向客户端提供自己的用户名和密码，客户端使用这些信息，向&ldquo;服务提供商&rdquo;索要授权。</p>\n\n<p>在这种模式下，用户必须把自己的密码给客户端，但是客户端不得存储密码。这种场景通常在对客户端高度信任的情况下。</p>\n\n<p><strong>（4）客户端模式。</strong></p>\n\n<p>客户端以自己的名义，而不是以用户的名义，向&ldquo;服务提供商&rdquo;进行认证。（直接通过传递client_id和client_secret向认证服务器获取token）。</p>\n', '1', '0', 'Java,面试', '', '/Uploads/images/article/2018/12/22/20181222070201.jpg', 'Java相关知识点整理《三》', '1');

-- ----------------------------
-- Table structure for xda_blog_channel
-- ----------------------------
DROP TABLE IF EXISTS `xda_blog_channel`;
CREATE TABLE `xda_blog_channel` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `description` varchar(1000) DEFAULT NULL COMMENT '备注字段',
  `is_del` tinyint(2) NOT NULL DEFAULT '0' COMMENT '删除标识（1删除，0未删除）',
  `last_modified_date` datetime DEFAULT NULL COMMENT '最近修改时间',
  `status` tinyint(2) NOT NULL DEFAULT '1' COMMENT '账号状态（1启用，0禁用）',
  `channel_name` varchar(64) NOT NULL COMMENT '栏目名称',
  `icon` varchar(64) DEFAULT NULL COMMENT 'icon样式',
  `is_blank` tinyint(2) DEFAULT '0' COMMENT '是否新窗口弹出',
  `parent_id` int(11) DEFAULT NULL COMMENT '父级栏目ID',
  `reorder` int(11) NOT NULL DEFAULT '1' COMMENT '排序',
  `uri` varchar(64) DEFAULT '#' COMMENT '链接地址',
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_lqpcyil6l6c166403lw57ul6g` (`channel_name`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of xda_blog_channel
-- ----------------------------
INSERT INTO `xda_blog_channel` VALUES ('1', '2018-11-24 15:37:12', '测试修改属性', '0', '2018-11-24 15:37:12', '1', '后端技术', null, '0', null, '1', '#');
INSERT INTO `xda_blog_channel` VALUES ('2', '2018-11-24 15:38:00', '测试修改属性', '0', '2018-11-24 15:38:00', '1', '前端技术', null, '0', null, '2', '#');
INSERT INTO `xda_blog_channel` VALUES ('3', '2018-11-24 15:38:38', '测试修改属性', '0', '2018-11-24 15:38:38', '1', '资源列表', null, '1', null, '4', '#');
INSERT INTO `xda_blog_channel` VALUES ('5', '2018-11-24 15:39:50', '测试修改属性', '0', '2018-12-14 15:58:56', '0', '动态', null, null, null, '3', '#');
INSERT INTO `xda_blog_channel` VALUES ('6', '2018-11-24 15:40:26', '测试修改属性', '0', '2018-11-24 15:40:26', '1', '活动', null, '0', null, '5', '#');
INSERT INTO `xda_blog_channel` VALUES ('7', '2018-12-14 13:43:26', '', '0', '2018-12-14 15:57:50', '1', 'JAVA', '', null, '1', '1', '#');
INSERT INTO `xda_blog_channel` VALUES ('10', '2018-12-14 13:45:00', '', '0', null, '1', 'PHP', '', '0', '1', '2', '#');
INSERT INTO `xda_blog_channel` VALUES ('14', '2018-12-14 16:13:17', '', '0', null, '1', 'SpringCloud', '', '0', '1', '3', '#');

-- ----------------------------
-- Table structure for xda_blog_comment
-- ----------------------------
DROP TABLE IF EXISTS `xda_blog_comment`;
CREATE TABLE `xda_blog_comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `description` varchar(1000) DEFAULT NULL COMMENT '备注字段',
  `is_del` tinyint(2) NOT NULL DEFAULT '0' COMMENT '删除标识（1删除，0未删除）',
  `last_modified_date` datetime DEFAULT NULL COMMENT '最近修改时间',
  `status` tinyint(2) NOT NULL DEFAULT '1' COMMENT '账号状态（1启用，0禁用）',
  `content` varchar(256) NOT NULL COMMENT '评论内容',
  `parent_id` int(11) DEFAULT NULL COMMENT '父级评论ID',
  `article_id` int(11) NOT NULL COMMENT '所属文章',
  `from_user_id` int(11) NOT NULL COMMENT '评论用户',
  `to_user_id` int(11) NOT NULL COMMENT '被评论用户',
  PRIMARY KEY (`id`),
  KEY `FKt53951ow43b7lbr3qpu5udk63` (`article_id`),
  KEY `FKn99e9i7o8de0g7b3uda3an5yt` (`from_user_id`),
  KEY `FKivgi4xax0qhyc6xff0r5206sf` (`to_user_id`),
  CONSTRAINT `FKivgi4xax0qhyc6xff0r5206sf` FOREIGN KEY (`to_user_id`) REFERENCES `xda_blog_user` (`id`),
  CONSTRAINT `FKn99e9i7o8de0g7b3uda3an5yt` FOREIGN KEY (`from_user_id`) REFERENCES `xda_blog_user` (`id`),
  CONSTRAINT `FKt53951ow43b7lbr3qpu5udk63` FOREIGN KEY (`article_id`) REFERENCES `xda_blog_article` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of xda_blog_comment
-- ----------------------------

-- ----------------------------
-- Table structure for xda_blog_links
-- ----------------------------
DROP TABLE IF EXISTS `xda_blog_links`;
CREATE TABLE `xda_blog_links` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `description` varchar(1000) DEFAULT NULL COMMENT '备注字段',
  `is_del` tinyint(2) NOT NULL DEFAULT '0' COMMENT '删除标识（1删除，0未删除）',
  `last_modified_date` datetime DEFAULT NULL COMMENT '最近修改时间',
  `status` tinyint(2) NOT NULL DEFAULT '1' COMMENT '账号状态（1启用，0禁用）',
  `is_blank` tinyint(2) DEFAULT '0' COMMENT '是否新窗口打开',
  `logo` varchar(255) DEFAULT NULL COMMENT '友情链接LOGO',
  `reorder` int(11) DEFAULT '1' COMMENT '排序',
  `title` varchar(255) NOT NULL COMMENT '友情链接标题',
  `url` varchar(255) DEFAULT '#' COMMENT '友情链接地址',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of xda_blog_links
-- ----------------------------
INSERT INTO `xda_blog_links` VALUES ('1', '2019-01-06 07:42:16', '', '0', '2019-01-06 07:42:16', '1', '0', '', '1', '番茄网', '#');
INSERT INTO `xda_blog_links` VALUES ('2', '2019-01-06 07:42:34', '', '0', '2019-01-06 07:42:34', '1', '0', '', '2', '飘花电影网', '#');
INSERT INTO `xda_blog_links` VALUES ('3', '2019-01-06 07:42:52', '', '0', '2019-01-06 07:42:52', '1', '0', '', '3', '秀逗啊', '#');
INSERT INTO `xda_blog_links` VALUES ('4', '2019-01-06 07:43:05', '', '0', '2019-01-06 07:43:05', '1', '0', '', '4', 'BD电影下载', '#');
INSERT INTO `xda_blog_links` VALUES ('5', '2019-01-06 07:43:18', '', '0', '2019-01-06 07:53:41', '1', '0', '/Uploads/images/links/2019/01/06/20190106075340.jpg', '5', 'YY6029', '#');
INSERT INTO `xda_blog_links` VALUES ('6', '2019-01-06 07:43:49', '', '0', '2019-01-06 07:43:49', '1', '0', '', '6', '堆糖', '#');
INSERT INTO `xda_blog_links` VALUES ('7', '2019-01-06 07:44:08', '', '0', '2019-01-06 07:44:08', '1', '0', '', '7', '51人人看电影', '#');
INSERT INTO `xda_blog_links` VALUES ('8', '2019-01-06 07:44:24', '', '0', '2019-01-06 07:55:14', '1', '0', '', '8', '中国网络菜市场', 'http://www.zgwlcsc.com');

-- ----------------------------
-- Table structure for xda_blog_user
-- ----------------------------
DROP TABLE IF EXISTS `xda_blog_user`;
CREATE TABLE `xda_blog_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `description` varchar(1000) DEFAULT NULL COMMENT '备注字段',
  `is_del` tinyint(2) NOT NULL DEFAULT '0' COMMENT '删除标识（1删除，0未删除）',
  `last_modified_date` datetime DEFAULT NULL COMMENT '最近修改时间',
  `status` tinyint(2) NOT NULL DEFAULT '1' COMMENT '账号状态（1启用，0禁用）',
  `login_secret` varchar(64) DEFAULT NULL COMMENT '登录安全码',
  `nick_name` varchar(64) DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) NOT NULL COMMENT '登录密码',
  `sex` varchar(10) NOT NULL COMMENT '性别',
  `thumb` varchar(64) DEFAULT NULL COMMENT '用户头像',
  `user_email` varchar(32) DEFAULT NULL COMMENT '用户邮箱',
  `user_phone` varchar(20) NOT NULL COMMENT '用户联系电话',
  `user_qq` varchar(32) DEFAULT NULL COMMENT '用户QQ号',
  `username` varchar(64) NOT NULL COMMENT '登录账号',
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_5wjc8fdj41fjfkafpxda9hfrb` (`username`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of xda_blog_user
-- ----------------------------
INSERT INTO `xda_blog_user` VALUES ('1', '2018-12-15 13:33:21', null, '0', null, '1', '', '颜值少年', '5d38ddf094c29b07f3b7507bdba32275', '男', '', 'justfresh@foxmail.com', '155****9776', '991058975', 'JustFresh');
INSERT INTO `xda_blog_user` VALUES ('2', '2018-12-15 13:35:54', null, '0', '2018-12-15 14:21:54', '0', '', '颜值代表', '5d38ddf094c29b07f3b7507bdba32275', '男', '', '1586753244@qq.com', '1368547633', '1586753244', 'pengjh');
INSERT INTO `xda_blog_user` VALUES ('3', '2018-12-15 13:36:41', null, '0', null, '1', '', '活泼的小仙女', '5d38ddf094c29b07f3b7507bdba32275', '女', '', '', '150****1758', '', 'lanlan');
INSERT INTO `xda_blog_user` VALUES ('4', '2018-12-15 13:37:34', null, '0', null, '1', '', '男神吴彦祖啊', '5d38ddf094c29b07f3b7507bdba32275', '男', '', '', '188****7548', '12345678', 'wuyanzu');
INSERT INTO `xda_blog_user` VALUES ('5', '2018-12-15 13:43:00', null, '0', '2018-12-15 14:21:41', '0', '', '男神不知道吗1111111', '5d38ddf094c29b07f3b7507bdba32275', '男', '', '74110@qq.com', '11012074110', '74110', 'man');
INSERT INTO `xda_blog_user` VALUES ('6', '2018-12-15 13:44:01', null, '0', null, '1', '', '女神逆天颜值哦', '5d38ddf094c29b07f3b7507bdba32275', '女', '', '212158647@qq.com', '13658**7456', '212158647', 'woman');
INSERT INTO `xda_blog_user` VALUES ('7', '2018-12-15 13:45:35', null, '0', null, '1', '', '上单无敌大盖伦', '5d38ddf094c29b07f3b7507bdba32275', '女', '', '123446625@qq.com', '139****1239', '', 'gailun');
INSERT INTO `xda_blog_user` VALUES ('8', '2018-12-15 13:47:16', null, '0', '2018-12-15 14:22:04', '0', '', '好运姐全靠一个R', '5d38ddf094c29b07f3b7507bdba32275', '女', '', '146***323@qq.com', '189****7547', '339***74534', 'adCarry');
INSERT INTO `xda_blog_user` VALUES ('9', '2018-12-15 13:48:43', null, '0', null, '1', '', '追风少年无限E', '5d38ddf094c29b07f3b7507bdba32275', '男', '', '2B2B2B@qq.com', '133****2222', '1211211234567', 'langdang');
INSERT INTO `xda_blog_user` VALUES ('10', '2018-12-15 13:50:05', null, '0', null, '1', '', '德玛西奥疯狂砍', '5d38ddf094c29b07f3b7507bdba32275', '男', '', '888***528@foxmail.com', '1888****5948', '888***528', 'aolafu');
INSERT INTO `xda_blog_user` VALUES ('11', '2018-12-15 13:54:18', null, '0', null, '1', '', 'mmp是什么鬼', '5d38ddf094c29b07f3b7507bdba32275', '男', '', '888***5344@foxmail.com', '1888****2641', '', 'mptest');
